// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: city/routing/v2/routing.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_city_2frouting_2fv2_2frouting_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_city_2frouting_2fv2_2frouting_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_city_2frouting_2fv2_2frouting_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_city_2frouting_2fv2_2frouting_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_city_2frouting_2fv2_2frouting_2eproto;
namespace city {
namespace routing {
namespace v2 {
class BusJourneyBody;
struct BusJourneyBodyDefaultTypeInternal;
extern BusJourneyBodyDefaultTypeInternal _BusJourneyBody_default_instance_;
class DrivingJourneyBody;
struct DrivingJourneyBodyDefaultTypeInternal;
extern DrivingJourneyBodyDefaultTypeInternal _DrivingJourneyBody_default_instance_;
class Journey;
struct JourneyDefaultTypeInternal;
extern JourneyDefaultTypeInternal _Journey_default_instance_;
class RoadStatus;
struct RoadStatusDefaultTypeInternal;
extern RoadStatusDefaultTypeInternal _RoadStatus_default_instance_;
class RoadStatuses;
struct RoadStatusesDefaultTypeInternal;
extern RoadStatusesDefaultTypeInternal _RoadStatuses_default_instance_;
class TransferSegment;
struct TransferSegmentDefaultTypeInternal;
extern TransferSegmentDefaultTypeInternal _TransferSegment_default_instance_;
class WalkingJourneyBody;
struct WalkingJourneyBodyDefaultTypeInternal;
extern WalkingJourneyBodyDefaultTypeInternal _WalkingJourneyBody_default_instance_;
class WalkingRouteSegment;
struct WalkingRouteSegmentDefaultTypeInternal;
extern WalkingRouteSegmentDefaultTypeInternal _WalkingRouteSegment_default_instance_;
}  // namespace v2
}  // namespace routing
}  // namespace city
PROTOBUF_NAMESPACE_OPEN
template<> ::city::routing::v2::BusJourneyBody* Arena::CreateMaybeMessage<::city::routing::v2::BusJourneyBody>(Arena*);
template<> ::city::routing::v2::DrivingJourneyBody* Arena::CreateMaybeMessage<::city::routing::v2::DrivingJourneyBody>(Arena*);
template<> ::city::routing::v2::Journey* Arena::CreateMaybeMessage<::city::routing::v2::Journey>(Arena*);
template<> ::city::routing::v2::RoadStatus* Arena::CreateMaybeMessage<::city::routing::v2::RoadStatus>(Arena*);
template<> ::city::routing::v2::RoadStatuses* Arena::CreateMaybeMessage<::city::routing::v2::RoadStatuses>(Arena*);
template<> ::city::routing::v2::TransferSegment* Arena::CreateMaybeMessage<::city::routing::v2::TransferSegment>(Arena*);
template<> ::city::routing::v2::WalkingJourneyBody* Arena::CreateMaybeMessage<::city::routing::v2::WalkingJourneyBody>(Arena*);
template<> ::city::routing::v2::WalkingRouteSegment* Arena::CreateMaybeMessage<::city::routing::v2::WalkingRouteSegment>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace city {
namespace routing {
namespace v2 {

enum RouteType : int {
  ROUTE_TYPE_UNSPECIFIED = 0,
  ROUTE_TYPE_DRIVING = 1,
  ROUTE_TYPE_WALKING = 2,
  ROUTE_TYPE_BY_BUS = 3,
  RouteType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouteType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouteType_IsValid(int value);
constexpr RouteType RouteType_MIN = ROUTE_TYPE_UNSPECIFIED;
constexpr RouteType RouteType_MAX = ROUTE_TYPE_BY_BUS;
constexpr int RouteType_ARRAYSIZE = RouteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteType_descriptor();
template<typename T>
inline const std::string& RouteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteType_descriptor(), enum_t_value);
}
inline bool RouteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteType>(
    RouteType_descriptor(), name, value);
}
enum JourneyType : int {
  JOURNEY_TYPE_UNSPECIFIED = 0,
  JOURNEY_TYPE_DRIVING = 1,
  JOURNEY_TYPE_WALKING = 2,
  JOURNEY_TYPE_BY_BUS = 3,
  JourneyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  JourneyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool JourneyType_IsValid(int value);
constexpr JourneyType JourneyType_MIN = JOURNEY_TYPE_UNSPECIFIED;
constexpr JourneyType JourneyType_MAX = JOURNEY_TYPE_BY_BUS;
constexpr int JourneyType_ARRAYSIZE = JourneyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JourneyType_descriptor();
template<typename T>
inline const std::string& JourneyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JourneyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JourneyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JourneyType_descriptor(), enum_t_value);
}
inline bool JourneyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JourneyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JourneyType>(
    JourneyType_descriptor(), name, value);
}
enum MovingDirection : int {
  MOVING_DIRECTION_UNSPECIFIED = 0,
  MOVING_DIRECTION_FORWARD = 1,
  MOVING_DIRECTION_BACKWARD = 2,
  MovingDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MovingDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MovingDirection_IsValid(int value);
constexpr MovingDirection MovingDirection_MIN = MOVING_DIRECTION_UNSPECIFIED;
constexpr MovingDirection MovingDirection_MAX = MOVING_DIRECTION_BACKWARD;
constexpr int MovingDirection_ARRAYSIZE = MovingDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MovingDirection_descriptor();
template<typename T>
inline const std::string& MovingDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MovingDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MovingDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MovingDirection_descriptor(), enum_t_value);
}
inline bool MovingDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MovingDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MovingDirection>(
    MovingDirection_descriptor(), name, value);
}
// ===================================================================

class DrivingJourneyBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.DrivingJourneyBody) */ {
 public:
  inline DrivingJourneyBody() : DrivingJourneyBody(nullptr) {}
  ~DrivingJourneyBody() override;
  explicit PROTOBUF_CONSTEXPR DrivingJourneyBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrivingJourneyBody(const DrivingJourneyBody& from);
  DrivingJourneyBody(DrivingJourneyBody&& from) noexcept
    : DrivingJourneyBody() {
    *this = ::std::move(from);
  }

  inline DrivingJourneyBody& operator=(const DrivingJourneyBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrivingJourneyBody& operator=(DrivingJourneyBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrivingJourneyBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrivingJourneyBody* internal_default_instance() {
    return reinterpret_cast<const DrivingJourneyBody*>(
               &_DrivingJourneyBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DrivingJourneyBody& a, DrivingJourneyBody& b) {
    a.Swap(&b);
  }
  inline void Swap(DrivingJourneyBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrivingJourneyBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrivingJourneyBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrivingJourneyBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrivingJourneyBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrivingJourneyBody& from) {
    DrivingJourneyBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrivingJourneyBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.DrivingJourneyBody";
  }
  protected:
  explicit DrivingJourneyBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadIdsFieldNumber = 2,
    kEtaFieldNumber = 3,
  };
  // repeated int32 road_ids = 2 [json_name = "roadIds"];
  int road_ids_size() const;
  private:
  int _internal_road_ids_size() const;
  public:
  void clear_road_ids();
  private:
  int32_t _internal_road_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_road_ids() const;
  void _internal_add_road_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_road_ids();
  public:
  int32_t road_ids(int index) const;
  void set_road_ids(int index, int32_t value);
  void add_road_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      road_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_road_ids();

  // double eta = 3 [json_name = "eta"];
  void clear_eta();
  double eta() const;
  void set_eta(double value);
  private:
  double _internal_eta() const;
  void _internal_set_eta(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.DrivingJourneyBody)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > road_ids_;
    mutable std::atomic<int> _road_ids_cached_byte_size_;
    double eta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class WalkingRouteSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.WalkingRouteSegment) */ {
 public:
  inline WalkingRouteSegment() : WalkingRouteSegment(nullptr) {}
  ~WalkingRouteSegment() override;
  explicit PROTOBUF_CONSTEXPR WalkingRouteSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalkingRouteSegment(const WalkingRouteSegment& from);
  WalkingRouteSegment(WalkingRouteSegment&& from) noexcept
    : WalkingRouteSegment() {
    *this = ::std::move(from);
  }

  inline WalkingRouteSegment& operator=(const WalkingRouteSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalkingRouteSegment& operator=(WalkingRouteSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalkingRouteSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalkingRouteSegment* internal_default_instance() {
    return reinterpret_cast<const WalkingRouteSegment*>(
               &_WalkingRouteSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WalkingRouteSegment& a, WalkingRouteSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(WalkingRouteSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalkingRouteSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalkingRouteSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalkingRouteSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalkingRouteSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalkingRouteSegment& from) {
    WalkingRouteSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalkingRouteSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.WalkingRouteSegment";
  }
  protected:
  explicit WalkingRouteSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneIdFieldNumber = 1,
    kMovingDirectionFieldNumber = 2,
  };
  // int32 lane_id = 1 [json_name = "laneId"];
  void clear_lane_id();
  int32_t lane_id() const;
  void set_lane_id(int32_t value);
  private:
  int32_t _internal_lane_id() const;
  void _internal_set_lane_id(int32_t value);
  public:

  // .city.routing.v2.MovingDirection moving_direction = 2 [json_name = "movingDirection"];
  void clear_moving_direction();
  ::city::routing::v2::MovingDirection moving_direction() const;
  void set_moving_direction(::city::routing::v2::MovingDirection value);
  private:
  ::city::routing::v2::MovingDirection _internal_moving_direction() const;
  void _internal_set_moving_direction(::city::routing::v2::MovingDirection value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.WalkingRouteSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t lane_id_;
    int moving_direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class WalkingJourneyBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.WalkingJourneyBody) */ {
 public:
  inline WalkingJourneyBody() : WalkingJourneyBody(nullptr) {}
  ~WalkingJourneyBody() override;
  explicit PROTOBUF_CONSTEXPR WalkingJourneyBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalkingJourneyBody(const WalkingJourneyBody& from);
  WalkingJourneyBody(WalkingJourneyBody&& from) noexcept
    : WalkingJourneyBody() {
    *this = ::std::move(from);
  }

  inline WalkingJourneyBody& operator=(const WalkingJourneyBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalkingJourneyBody& operator=(WalkingJourneyBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalkingJourneyBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalkingJourneyBody* internal_default_instance() {
    return reinterpret_cast<const WalkingJourneyBody*>(
               &_WalkingJourneyBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WalkingJourneyBody& a, WalkingJourneyBody& b) {
    a.Swap(&b);
  }
  inline void Swap(WalkingJourneyBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalkingJourneyBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalkingJourneyBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalkingJourneyBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalkingJourneyBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalkingJourneyBody& from) {
    WalkingJourneyBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalkingJourneyBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.WalkingJourneyBody";
  }
  protected:
  explicit WalkingJourneyBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRouteFieldNumber = 1,
    kEtaFieldNumber = 2,
  };
  // repeated .city.routing.v2.WalkingRouteSegment route = 1 [json_name = "route"];
  int route_size() const;
  private:
  int _internal_route_size() const;
  public:
  void clear_route();
  ::city::routing::v2::WalkingRouteSegment* mutable_route(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::WalkingRouteSegment >*
      mutable_route();
  private:
  const ::city::routing::v2::WalkingRouteSegment& _internal_route(int index) const;
  ::city::routing::v2::WalkingRouteSegment* _internal_add_route();
  public:
  const ::city::routing::v2::WalkingRouteSegment& route(int index) const;
  ::city::routing::v2::WalkingRouteSegment* add_route();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::WalkingRouteSegment >&
      route() const;

  // double eta = 2 [json_name = "eta"];
  void clear_eta();
  double eta() const;
  void set_eta(double value);
  private:
  double _internal_eta() const;
  void _internal_set_eta(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.WalkingJourneyBody)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::WalkingRouteSegment > route_;
    double eta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class TransferSegment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.TransferSegment) */ {
 public:
  inline TransferSegment() : TransferSegment(nullptr) {}
  ~TransferSegment() override;
  explicit PROTOBUF_CONSTEXPR TransferSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferSegment(const TransferSegment& from);
  TransferSegment(TransferSegment&& from) noexcept
    : TransferSegment() {
    *this = ::std::move(from);
  }

  inline TransferSegment& operator=(const TransferSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferSegment& operator=(TransferSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferSegment* internal_default_instance() {
    return reinterpret_cast<const TransferSegment*>(
               &_TransferSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TransferSegment& a, TransferSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferSegment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferSegment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferSegment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferSegment& from) {
    TransferSegment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferSegment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.TransferSegment";
  }
  protected:
  explicit TransferSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSublineIdFieldNumber = 1,
    kStartStationIdFieldNumber = 2,
    kEndStationIdFieldNumber = 3,
  };
  // int32 subline_id = 1 [json_name = "sublineId"];
  void clear_subline_id();
  int32_t subline_id() const;
  void set_subline_id(int32_t value);
  private:
  int32_t _internal_subline_id() const;
  void _internal_set_subline_id(int32_t value);
  public:

  // int32 start_station_id = 2 [json_name = "startStationId"];
  void clear_start_station_id();
  int32_t start_station_id() const;
  void set_start_station_id(int32_t value);
  private:
  int32_t _internal_start_station_id() const;
  void _internal_set_start_station_id(int32_t value);
  public:

  // int32 end_station_id = 3 [json_name = "endStationId"];
  void clear_end_station_id();
  int32_t end_station_id() const;
  void set_end_station_id(int32_t value);
  private:
  int32_t _internal_end_station_id() const;
  void _internal_set_end_station_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.TransferSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t subline_id_;
    int32_t start_station_id_;
    int32_t end_station_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class BusJourneyBody final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.BusJourneyBody) */ {
 public:
  inline BusJourneyBody() : BusJourneyBody(nullptr) {}
  ~BusJourneyBody() override;
  explicit PROTOBUF_CONSTEXPR BusJourneyBody(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BusJourneyBody(const BusJourneyBody& from);
  BusJourneyBody(BusJourneyBody&& from) noexcept
    : BusJourneyBody() {
    *this = ::std::move(from);
  }

  inline BusJourneyBody& operator=(const BusJourneyBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline BusJourneyBody& operator=(BusJourneyBody&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BusJourneyBody& default_instance() {
    return *internal_default_instance();
  }
  static inline const BusJourneyBody* internal_default_instance() {
    return reinterpret_cast<const BusJourneyBody*>(
               &_BusJourneyBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BusJourneyBody& a, BusJourneyBody& b) {
    a.Swap(&b);
  }
  inline void Swap(BusJourneyBody* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BusJourneyBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BusJourneyBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BusJourneyBody>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BusJourneyBody& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BusJourneyBody& from) {
    BusJourneyBody::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BusJourneyBody* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.BusJourneyBody";
  }
  protected:
  explicit BusJourneyBody(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransfersFieldNumber = 1,
    kEtaFieldNumber = 2,
  };
  // repeated .city.routing.v2.TransferSegment transfers = 1 [json_name = "transfers"];
  int transfers_size() const;
  private:
  int _internal_transfers_size() const;
  public:
  void clear_transfers();
  ::city::routing::v2::TransferSegment* mutable_transfers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::TransferSegment >*
      mutable_transfers();
  private:
  const ::city::routing::v2::TransferSegment& _internal_transfers(int index) const;
  ::city::routing::v2::TransferSegment* _internal_add_transfers();
  public:
  const ::city::routing::v2::TransferSegment& transfers(int index) const;
  ::city::routing::v2::TransferSegment* add_transfers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::TransferSegment >&
      transfers() const;

  // double eta = 2 [json_name = "eta"];
  void clear_eta();
  double eta() const;
  void set_eta(double value);
  private:
  double _internal_eta() const;
  void _internal_set_eta(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.BusJourneyBody)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::TransferSegment > transfers_;
    double eta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class Journey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.Journey) */ {
 public:
  inline Journey() : Journey(nullptr) {}
  ~Journey() override;
  explicit PROTOBUF_CONSTEXPR Journey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Journey(const Journey& from);
  Journey(Journey&& from) noexcept
    : Journey() {
    *this = ::std::move(from);
  }

  inline Journey& operator=(const Journey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Journey& operator=(Journey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Journey& default_instance() {
    return *internal_default_instance();
  }
  static inline const Journey* internal_default_instance() {
    return reinterpret_cast<const Journey*>(
               &_Journey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Journey& a, Journey& b) {
    a.Swap(&b);
  }
  inline void Swap(Journey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Journey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Journey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Journey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Journey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Journey& from) {
    Journey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Journey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.Journey";
  }
  protected:
  explicit Journey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrivingFieldNumber = 2,
    kWalkingFieldNumber = 3,
    kByBusFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional .city.routing.v2.DrivingJourneyBody driving = 2 [json_name = "driving"];
  bool has_driving() const;
  private:
  bool _internal_has_driving() const;
  public:
  void clear_driving();
  const ::city::routing::v2::DrivingJourneyBody& driving() const;
  PROTOBUF_NODISCARD ::city::routing::v2::DrivingJourneyBody* release_driving();
  ::city::routing::v2::DrivingJourneyBody* mutable_driving();
  void set_allocated_driving(::city::routing::v2::DrivingJourneyBody* driving);
  private:
  const ::city::routing::v2::DrivingJourneyBody& _internal_driving() const;
  ::city::routing::v2::DrivingJourneyBody* _internal_mutable_driving();
  public:
  void unsafe_arena_set_allocated_driving(
      ::city::routing::v2::DrivingJourneyBody* driving);
  ::city::routing::v2::DrivingJourneyBody* unsafe_arena_release_driving();

  // optional .city.routing.v2.WalkingJourneyBody walking = 3 [json_name = "walking"];
  bool has_walking() const;
  private:
  bool _internal_has_walking() const;
  public:
  void clear_walking();
  const ::city::routing::v2::WalkingJourneyBody& walking() const;
  PROTOBUF_NODISCARD ::city::routing::v2::WalkingJourneyBody* release_walking();
  ::city::routing::v2::WalkingJourneyBody* mutable_walking();
  void set_allocated_walking(::city::routing::v2::WalkingJourneyBody* walking);
  private:
  const ::city::routing::v2::WalkingJourneyBody& _internal_walking() const;
  ::city::routing::v2::WalkingJourneyBody* _internal_mutable_walking();
  public:
  void unsafe_arena_set_allocated_walking(
      ::city::routing::v2::WalkingJourneyBody* walking);
  ::city::routing::v2::WalkingJourneyBody* unsafe_arena_release_walking();

  // optional .city.routing.v2.BusJourneyBody by_bus = 4 [json_name = "byBus"];
  bool has_by_bus() const;
  private:
  bool _internal_has_by_bus() const;
  public:
  void clear_by_bus();
  const ::city::routing::v2::BusJourneyBody& by_bus() const;
  PROTOBUF_NODISCARD ::city::routing::v2::BusJourneyBody* release_by_bus();
  ::city::routing::v2::BusJourneyBody* mutable_by_bus();
  void set_allocated_by_bus(::city::routing::v2::BusJourneyBody* by_bus);
  private:
  const ::city::routing::v2::BusJourneyBody& _internal_by_bus() const;
  ::city::routing::v2::BusJourneyBody* _internal_mutable_by_bus();
  public:
  void unsafe_arena_set_allocated_by_bus(
      ::city::routing::v2::BusJourneyBody* by_bus);
  ::city::routing::v2::BusJourneyBody* unsafe_arena_release_by_bus();

  // .city.routing.v2.JourneyType type = 1 [json_name = "type"];
  void clear_type();
  ::city::routing::v2::JourneyType type() const;
  void set_type(::city::routing::v2::JourneyType value);
  private:
  ::city::routing::v2::JourneyType _internal_type() const;
  void _internal_set_type(::city::routing::v2::JourneyType value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.Journey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::city::routing::v2::DrivingJourneyBody* driving_;
    ::city::routing::v2::WalkingJourneyBody* walking_;
    ::city::routing::v2::BusJourneyBody* by_bus_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class RoadStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.RoadStatus) */ {
 public:
  inline RoadStatus() : RoadStatus(nullptr) {}
  ~RoadStatus() override;
  explicit PROTOBUF_CONSTEXPR RoadStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoadStatus(const RoadStatus& from);
  RoadStatus(RoadStatus&& from) noexcept
    : RoadStatus() {
    *this = ::std::move(from);
  }

  inline RoadStatus& operator=(const RoadStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadStatus& operator=(RoadStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadStatus* internal_default_instance() {
    return reinterpret_cast<const RoadStatus*>(
               &_RoadStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RoadStatus& a, RoadStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoadStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoadStatus& from) {
    RoadStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.RoadStatus";
  }
  protected:
  explicit RoadStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated double speed = 2 [json_name = "speed"];
  int speed_size() const;
  private:
  int _internal_speed_size() const;
  public:
  void clear_speed();
  private:
  double _internal_speed(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_speed() const;
  void _internal_add_speed(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_speed();
  public:
  double speed(int index) const;
  void set_speed(int index, double value);
  void add_speed(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      speed() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_speed();

  // int32 id = 1 [json_name = "id"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:city.routing.v2.RoadStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > speed_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// -------------------------------------------------------------------

class RoadStatuses final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.routing.v2.RoadStatuses) */ {
 public:
  inline RoadStatuses() : RoadStatuses(nullptr) {}
  ~RoadStatuses() override;
  explicit PROTOBUF_CONSTEXPR RoadStatuses(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoadStatuses(const RoadStatuses& from);
  RoadStatuses(RoadStatuses&& from) noexcept
    : RoadStatuses() {
    *this = ::std::move(from);
  }

  inline RoadStatuses& operator=(const RoadStatuses& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadStatuses& operator=(RoadStatuses&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadStatuses& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadStatuses* internal_default_instance() {
    return reinterpret_cast<const RoadStatuses*>(
               &_RoadStatuses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoadStatuses& a, RoadStatuses& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadStatuses* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadStatuses* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadStatuses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadStatuses>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoadStatuses& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoadStatuses& from) {
    RoadStatuses::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadStatuses* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.routing.v2.RoadStatuses";
  }
  protected:
  explicit RoadStatuses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadStatusesFieldNumber = 1,
  };
  // repeated .city.routing.v2.RoadStatus road_statuses = 1 [json_name = "roadStatuses"];
  int road_statuses_size() const;
  private:
  int _internal_road_statuses_size() const;
  public:
  void clear_road_statuses();
  ::city::routing::v2::RoadStatus* mutable_road_statuses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::RoadStatus >*
      mutable_road_statuses();
  private:
  const ::city::routing::v2::RoadStatus& _internal_road_statuses(int index) const;
  ::city::routing::v2::RoadStatus* _internal_add_road_statuses();
  public:
  const ::city::routing::v2::RoadStatus& road_statuses(int index) const;
  ::city::routing::v2::RoadStatus* add_road_statuses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::RoadStatus >&
      road_statuses() const;

  // @@protoc_insertion_point(class_scope:city.routing.v2.RoadStatuses)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::RoadStatus > road_statuses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2frouting_2fv2_2frouting_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DrivingJourneyBody

// repeated int32 road_ids = 2 [json_name = "roadIds"];
inline int DrivingJourneyBody::_internal_road_ids_size() const {
  return _impl_.road_ids_.size();
}
inline int DrivingJourneyBody::road_ids_size() const {
  return _internal_road_ids_size();
}
inline void DrivingJourneyBody::clear_road_ids() {
  _impl_.road_ids_.Clear();
}
inline int32_t DrivingJourneyBody::_internal_road_ids(int index) const {
  return _impl_.road_ids_.Get(index);
}
inline int32_t DrivingJourneyBody::road_ids(int index) const {
  // @@protoc_insertion_point(field_get:city.routing.v2.DrivingJourneyBody.road_ids)
  return _internal_road_ids(index);
}
inline void DrivingJourneyBody::set_road_ids(int index, int32_t value) {
  _impl_.road_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:city.routing.v2.DrivingJourneyBody.road_ids)
}
inline void DrivingJourneyBody::_internal_add_road_ids(int32_t value) {
  _impl_.road_ids_.Add(value);
}
inline void DrivingJourneyBody::add_road_ids(int32_t value) {
  _internal_add_road_ids(value);
  // @@protoc_insertion_point(field_add:city.routing.v2.DrivingJourneyBody.road_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DrivingJourneyBody::_internal_road_ids() const {
  return _impl_.road_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
DrivingJourneyBody::road_ids() const {
  // @@protoc_insertion_point(field_list:city.routing.v2.DrivingJourneyBody.road_ids)
  return _internal_road_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DrivingJourneyBody::_internal_mutable_road_ids() {
  return &_impl_.road_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
DrivingJourneyBody::mutable_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:city.routing.v2.DrivingJourneyBody.road_ids)
  return _internal_mutable_road_ids();
}

// double eta = 3 [json_name = "eta"];
inline void DrivingJourneyBody::clear_eta() {
  _impl_.eta_ = 0;
}
inline double DrivingJourneyBody::_internal_eta() const {
  return _impl_.eta_;
}
inline double DrivingJourneyBody::eta() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.DrivingJourneyBody.eta)
  return _internal_eta();
}
inline void DrivingJourneyBody::_internal_set_eta(double value) {
  
  _impl_.eta_ = value;
}
inline void DrivingJourneyBody::set_eta(double value) {
  _internal_set_eta(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.DrivingJourneyBody.eta)
}

// -------------------------------------------------------------------

// WalkingRouteSegment

// int32 lane_id = 1 [json_name = "laneId"];
inline void WalkingRouteSegment::clear_lane_id() {
  _impl_.lane_id_ = 0;
}
inline int32_t WalkingRouteSegment::_internal_lane_id() const {
  return _impl_.lane_id_;
}
inline int32_t WalkingRouteSegment::lane_id() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.WalkingRouteSegment.lane_id)
  return _internal_lane_id();
}
inline void WalkingRouteSegment::_internal_set_lane_id(int32_t value) {
  
  _impl_.lane_id_ = value;
}
inline void WalkingRouteSegment::set_lane_id(int32_t value) {
  _internal_set_lane_id(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.WalkingRouteSegment.lane_id)
}

// .city.routing.v2.MovingDirection moving_direction = 2 [json_name = "movingDirection"];
inline void WalkingRouteSegment::clear_moving_direction() {
  _impl_.moving_direction_ = 0;
}
inline ::city::routing::v2::MovingDirection WalkingRouteSegment::_internal_moving_direction() const {
  return static_cast< ::city::routing::v2::MovingDirection >(_impl_.moving_direction_);
}
inline ::city::routing::v2::MovingDirection WalkingRouteSegment::moving_direction() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.WalkingRouteSegment.moving_direction)
  return _internal_moving_direction();
}
inline void WalkingRouteSegment::_internal_set_moving_direction(::city::routing::v2::MovingDirection value) {
  
  _impl_.moving_direction_ = value;
}
inline void WalkingRouteSegment::set_moving_direction(::city::routing::v2::MovingDirection value) {
  _internal_set_moving_direction(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.WalkingRouteSegment.moving_direction)
}

// -------------------------------------------------------------------

// WalkingJourneyBody

// repeated .city.routing.v2.WalkingRouteSegment route = 1 [json_name = "route"];
inline int WalkingJourneyBody::_internal_route_size() const {
  return _impl_.route_.size();
}
inline int WalkingJourneyBody::route_size() const {
  return _internal_route_size();
}
inline void WalkingJourneyBody::clear_route() {
  _impl_.route_.Clear();
}
inline ::city::routing::v2::WalkingRouteSegment* WalkingJourneyBody::mutable_route(int index) {
  // @@protoc_insertion_point(field_mutable:city.routing.v2.WalkingJourneyBody.route)
  return _impl_.route_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::WalkingRouteSegment >*
WalkingJourneyBody::mutable_route() {
  // @@protoc_insertion_point(field_mutable_list:city.routing.v2.WalkingJourneyBody.route)
  return &_impl_.route_;
}
inline const ::city::routing::v2::WalkingRouteSegment& WalkingJourneyBody::_internal_route(int index) const {
  return _impl_.route_.Get(index);
}
inline const ::city::routing::v2::WalkingRouteSegment& WalkingJourneyBody::route(int index) const {
  // @@protoc_insertion_point(field_get:city.routing.v2.WalkingJourneyBody.route)
  return _internal_route(index);
}
inline ::city::routing::v2::WalkingRouteSegment* WalkingJourneyBody::_internal_add_route() {
  return _impl_.route_.Add();
}
inline ::city::routing::v2::WalkingRouteSegment* WalkingJourneyBody::add_route() {
  ::city::routing::v2::WalkingRouteSegment* _add = _internal_add_route();
  // @@protoc_insertion_point(field_add:city.routing.v2.WalkingJourneyBody.route)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::WalkingRouteSegment >&
WalkingJourneyBody::route() const {
  // @@protoc_insertion_point(field_list:city.routing.v2.WalkingJourneyBody.route)
  return _impl_.route_;
}

// double eta = 2 [json_name = "eta"];
inline void WalkingJourneyBody::clear_eta() {
  _impl_.eta_ = 0;
}
inline double WalkingJourneyBody::_internal_eta() const {
  return _impl_.eta_;
}
inline double WalkingJourneyBody::eta() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.WalkingJourneyBody.eta)
  return _internal_eta();
}
inline void WalkingJourneyBody::_internal_set_eta(double value) {
  
  _impl_.eta_ = value;
}
inline void WalkingJourneyBody::set_eta(double value) {
  _internal_set_eta(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.WalkingJourneyBody.eta)
}

// -------------------------------------------------------------------

// TransferSegment

// int32 subline_id = 1 [json_name = "sublineId"];
inline void TransferSegment::clear_subline_id() {
  _impl_.subline_id_ = 0;
}
inline int32_t TransferSegment::_internal_subline_id() const {
  return _impl_.subline_id_;
}
inline int32_t TransferSegment::subline_id() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.TransferSegment.subline_id)
  return _internal_subline_id();
}
inline void TransferSegment::_internal_set_subline_id(int32_t value) {
  
  _impl_.subline_id_ = value;
}
inline void TransferSegment::set_subline_id(int32_t value) {
  _internal_set_subline_id(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.TransferSegment.subline_id)
}

// int32 start_station_id = 2 [json_name = "startStationId"];
inline void TransferSegment::clear_start_station_id() {
  _impl_.start_station_id_ = 0;
}
inline int32_t TransferSegment::_internal_start_station_id() const {
  return _impl_.start_station_id_;
}
inline int32_t TransferSegment::start_station_id() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.TransferSegment.start_station_id)
  return _internal_start_station_id();
}
inline void TransferSegment::_internal_set_start_station_id(int32_t value) {
  
  _impl_.start_station_id_ = value;
}
inline void TransferSegment::set_start_station_id(int32_t value) {
  _internal_set_start_station_id(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.TransferSegment.start_station_id)
}

// int32 end_station_id = 3 [json_name = "endStationId"];
inline void TransferSegment::clear_end_station_id() {
  _impl_.end_station_id_ = 0;
}
inline int32_t TransferSegment::_internal_end_station_id() const {
  return _impl_.end_station_id_;
}
inline int32_t TransferSegment::end_station_id() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.TransferSegment.end_station_id)
  return _internal_end_station_id();
}
inline void TransferSegment::_internal_set_end_station_id(int32_t value) {
  
  _impl_.end_station_id_ = value;
}
inline void TransferSegment::set_end_station_id(int32_t value) {
  _internal_set_end_station_id(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.TransferSegment.end_station_id)
}

// -------------------------------------------------------------------

// BusJourneyBody

// repeated .city.routing.v2.TransferSegment transfers = 1 [json_name = "transfers"];
inline int BusJourneyBody::_internal_transfers_size() const {
  return _impl_.transfers_.size();
}
inline int BusJourneyBody::transfers_size() const {
  return _internal_transfers_size();
}
inline void BusJourneyBody::clear_transfers() {
  _impl_.transfers_.Clear();
}
inline ::city::routing::v2::TransferSegment* BusJourneyBody::mutable_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:city.routing.v2.BusJourneyBody.transfers)
  return _impl_.transfers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::TransferSegment >*
BusJourneyBody::mutable_transfers() {
  // @@protoc_insertion_point(field_mutable_list:city.routing.v2.BusJourneyBody.transfers)
  return &_impl_.transfers_;
}
inline const ::city::routing::v2::TransferSegment& BusJourneyBody::_internal_transfers(int index) const {
  return _impl_.transfers_.Get(index);
}
inline const ::city::routing::v2::TransferSegment& BusJourneyBody::transfers(int index) const {
  // @@protoc_insertion_point(field_get:city.routing.v2.BusJourneyBody.transfers)
  return _internal_transfers(index);
}
inline ::city::routing::v2::TransferSegment* BusJourneyBody::_internal_add_transfers() {
  return _impl_.transfers_.Add();
}
inline ::city::routing::v2::TransferSegment* BusJourneyBody::add_transfers() {
  ::city::routing::v2::TransferSegment* _add = _internal_add_transfers();
  // @@protoc_insertion_point(field_add:city.routing.v2.BusJourneyBody.transfers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::TransferSegment >&
BusJourneyBody::transfers() const {
  // @@protoc_insertion_point(field_list:city.routing.v2.BusJourneyBody.transfers)
  return _impl_.transfers_;
}

// double eta = 2 [json_name = "eta"];
inline void BusJourneyBody::clear_eta() {
  _impl_.eta_ = 0;
}
inline double BusJourneyBody::_internal_eta() const {
  return _impl_.eta_;
}
inline double BusJourneyBody::eta() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.BusJourneyBody.eta)
  return _internal_eta();
}
inline void BusJourneyBody::_internal_set_eta(double value) {
  
  _impl_.eta_ = value;
}
inline void BusJourneyBody::set_eta(double value) {
  _internal_set_eta(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.BusJourneyBody.eta)
}

// -------------------------------------------------------------------

// Journey

// .city.routing.v2.JourneyType type = 1 [json_name = "type"];
inline void Journey::clear_type() {
  _impl_.type_ = 0;
}
inline ::city::routing::v2::JourneyType Journey::_internal_type() const {
  return static_cast< ::city::routing::v2::JourneyType >(_impl_.type_);
}
inline ::city::routing::v2::JourneyType Journey::type() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.Journey.type)
  return _internal_type();
}
inline void Journey::_internal_set_type(::city::routing::v2::JourneyType value) {
  
  _impl_.type_ = value;
}
inline void Journey::set_type(::city::routing::v2::JourneyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.Journey.type)
}

// optional .city.routing.v2.DrivingJourneyBody driving = 2 [json_name = "driving"];
inline bool Journey::_internal_has_driving() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.driving_ != nullptr);
  return value;
}
inline bool Journey::has_driving() const {
  return _internal_has_driving();
}
inline void Journey::clear_driving() {
  if (_impl_.driving_ != nullptr) _impl_.driving_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::city::routing::v2::DrivingJourneyBody& Journey::_internal_driving() const {
  const ::city::routing::v2::DrivingJourneyBody* p = _impl_.driving_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::routing::v2::DrivingJourneyBody&>(
      ::city::routing::v2::_DrivingJourneyBody_default_instance_);
}
inline const ::city::routing::v2::DrivingJourneyBody& Journey::driving() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.Journey.driving)
  return _internal_driving();
}
inline void Journey::unsafe_arena_set_allocated_driving(
    ::city::routing::v2::DrivingJourneyBody* driving) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.driving_);
  }
  _impl_.driving_ = driving;
  if (driving) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.routing.v2.Journey.driving)
}
inline ::city::routing::v2::DrivingJourneyBody* Journey::release_driving() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::routing::v2::DrivingJourneyBody* temp = _impl_.driving_;
  _impl_.driving_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::routing::v2::DrivingJourneyBody* Journey::unsafe_arena_release_driving() {
  // @@protoc_insertion_point(field_release:city.routing.v2.Journey.driving)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::routing::v2::DrivingJourneyBody* temp = _impl_.driving_;
  _impl_.driving_ = nullptr;
  return temp;
}
inline ::city::routing::v2::DrivingJourneyBody* Journey::_internal_mutable_driving() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.driving_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::routing::v2::DrivingJourneyBody>(GetArenaForAllocation());
    _impl_.driving_ = p;
  }
  return _impl_.driving_;
}
inline ::city::routing::v2::DrivingJourneyBody* Journey::mutable_driving() {
  ::city::routing::v2::DrivingJourneyBody* _msg = _internal_mutable_driving();
  // @@protoc_insertion_point(field_mutable:city.routing.v2.Journey.driving)
  return _msg;
}
inline void Journey::set_allocated_driving(::city::routing::v2::DrivingJourneyBody* driving) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.driving_;
  }
  if (driving) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(driving);
    if (message_arena != submessage_arena) {
      driving = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, driving, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.driving_ = driving;
  // @@protoc_insertion_point(field_set_allocated:city.routing.v2.Journey.driving)
}

// optional .city.routing.v2.WalkingJourneyBody walking = 3 [json_name = "walking"];
inline bool Journey::_internal_has_walking() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.walking_ != nullptr);
  return value;
}
inline bool Journey::has_walking() const {
  return _internal_has_walking();
}
inline void Journey::clear_walking() {
  if (_impl_.walking_ != nullptr) _impl_.walking_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::city::routing::v2::WalkingJourneyBody& Journey::_internal_walking() const {
  const ::city::routing::v2::WalkingJourneyBody* p = _impl_.walking_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::routing::v2::WalkingJourneyBody&>(
      ::city::routing::v2::_WalkingJourneyBody_default_instance_);
}
inline const ::city::routing::v2::WalkingJourneyBody& Journey::walking() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.Journey.walking)
  return _internal_walking();
}
inline void Journey::unsafe_arena_set_allocated_walking(
    ::city::routing::v2::WalkingJourneyBody* walking) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.walking_);
  }
  _impl_.walking_ = walking;
  if (walking) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.routing.v2.Journey.walking)
}
inline ::city::routing::v2::WalkingJourneyBody* Journey::release_walking() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::routing::v2::WalkingJourneyBody* temp = _impl_.walking_;
  _impl_.walking_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::routing::v2::WalkingJourneyBody* Journey::unsafe_arena_release_walking() {
  // @@protoc_insertion_point(field_release:city.routing.v2.Journey.walking)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::routing::v2::WalkingJourneyBody* temp = _impl_.walking_;
  _impl_.walking_ = nullptr;
  return temp;
}
inline ::city::routing::v2::WalkingJourneyBody* Journey::_internal_mutable_walking() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.walking_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::routing::v2::WalkingJourneyBody>(GetArenaForAllocation());
    _impl_.walking_ = p;
  }
  return _impl_.walking_;
}
inline ::city::routing::v2::WalkingJourneyBody* Journey::mutable_walking() {
  ::city::routing::v2::WalkingJourneyBody* _msg = _internal_mutable_walking();
  // @@protoc_insertion_point(field_mutable:city.routing.v2.Journey.walking)
  return _msg;
}
inline void Journey::set_allocated_walking(::city::routing::v2::WalkingJourneyBody* walking) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.walking_;
  }
  if (walking) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(walking);
    if (message_arena != submessage_arena) {
      walking = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, walking, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.walking_ = walking;
  // @@protoc_insertion_point(field_set_allocated:city.routing.v2.Journey.walking)
}

// optional .city.routing.v2.BusJourneyBody by_bus = 4 [json_name = "byBus"];
inline bool Journey::_internal_has_by_bus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.by_bus_ != nullptr);
  return value;
}
inline bool Journey::has_by_bus() const {
  return _internal_has_by_bus();
}
inline void Journey::clear_by_bus() {
  if (_impl_.by_bus_ != nullptr) _impl_.by_bus_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::city::routing::v2::BusJourneyBody& Journey::_internal_by_bus() const {
  const ::city::routing::v2::BusJourneyBody* p = _impl_.by_bus_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::routing::v2::BusJourneyBody&>(
      ::city::routing::v2::_BusJourneyBody_default_instance_);
}
inline const ::city::routing::v2::BusJourneyBody& Journey::by_bus() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.Journey.by_bus)
  return _internal_by_bus();
}
inline void Journey::unsafe_arena_set_allocated_by_bus(
    ::city::routing::v2::BusJourneyBody* by_bus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.by_bus_);
  }
  _impl_.by_bus_ = by_bus;
  if (by_bus) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.routing.v2.Journey.by_bus)
}
inline ::city::routing::v2::BusJourneyBody* Journey::release_by_bus() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::routing::v2::BusJourneyBody* temp = _impl_.by_bus_;
  _impl_.by_bus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::routing::v2::BusJourneyBody* Journey::unsafe_arena_release_by_bus() {
  // @@protoc_insertion_point(field_release:city.routing.v2.Journey.by_bus)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::routing::v2::BusJourneyBody* temp = _impl_.by_bus_;
  _impl_.by_bus_ = nullptr;
  return temp;
}
inline ::city::routing::v2::BusJourneyBody* Journey::_internal_mutable_by_bus() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.by_bus_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::routing::v2::BusJourneyBody>(GetArenaForAllocation());
    _impl_.by_bus_ = p;
  }
  return _impl_.by_bus_;
}
inline ::city::routing::v2::BusJourneyBody* Journey::mutable_by_bus() {
  ::city::routing::v2::BusJourneyBody* _msg = _internal_mutable_by_bus();
  // @@protoc_insertion_point(field_mutable:city.routing.v2.Journey.by_bus)
  return _msg;
}
inline void Journey::set_allocated_by_bus(::city::routing::v2::BusJourneyBody* by_bus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.by_bus_;
  }
  if (by_bus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(by_bus);
    if (message_arena != submessage_arena) {
      by_bus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, by_bus, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.by_bus_ = by_bus;
  // @@protoc_insertion_point(field_set_allocated:city.routing.v2.Journey.by_bus)
}

// -------------------------------------------------------------------

// RoadStatus

// int32 id = 1 [json_name = "id"];
inline void RoadStatus::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t RoadStatus::_internal_id() const {
  return _impl_.id_;
}
inline int32_t RoadStatus::id() const {
  // @@protoc_insertion_point(field_get:city.routing.v2.RoadStatus.id)
  return _internal_id();
}
inline void RoadStatus::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void RoadStatus::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.routing.v2.RoadStatus.id)
}

// repeated double speed = 2 [json_name = "speed"];
inline int RoadStatus::_internal_speed_size() const {
  return _impl_.speed_.size();
}
inline int RoadStatus::speed_size() const {
  return _internal_speed_size();
}
inline void RoadStatus::clear_speed() {
  _impl_.speed_.Clear();
}
inline double RoadStatus::_internal_speed(int index) const {
  return _impl_.speed_.Get(index);
}
inline double RoadStatus::speed(int index) const {
  // @@protoc_insertion_point(field_get:city.routing.v2.RoadStatus.speed)
  return _internal_speed(index);
}
inline void RoadStatus::set_speed(int index, double value) {
  _impl_.speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:city.routing.v2.RoadStatus.speed)
}
inline void RoadStatus::_internal_add_speed(double value) {
  _impl_.speed_.Add(value);
}
inline void RoadStatus::add_speed(double value) {
  _internal_add_speed(value);
  // @@protoc_insertion_point(field_add:city.routing.v2.RoadStatus.speed)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RoadStatus::_internal_speed() const {
  return _impl_.speed_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RoadStatus::speed() const {
  // @@protoc_insertion_point(field_list:city.routing.v2.RoadStatus.speed)
  return _internal_speed();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RoadStatus::_internal_mutable_speed() {
  return &_impl_.speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RoadStatus::mutable_speed() {
  // @@protoc_insertion_point(field_mutable_list:city.routing.v2.RoadStatus.speed)
  return _internal_mutable_speed();
}

// -------------------------------------------------------------------

// RoadStatuses

// repeated .city.routing.v2.RoadStatus road_statuses = 1 [json_name = "roadStatuses"];
inline int RoadStatuses::_internal_road_statuses_size() const {
  return _impl_.road_statuses_.size();
}
inline int RoadStatuses::road_statuses_size() const {
  return _internal_road_statuses_size();
}
inline void RoadStatuses::clear_road_statuses() {
  _impl_.road_statuses_.Clear();
}
inline ::city::routing::v2::RoadStatus* RoadStatuses::mutable_road_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:city.routing.v2.RoadStatuses.road_statuses)
  return _impl_.road_statuses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::RoadStatus >*
RoadStatuses::mutable_road_statuses() {
  // @@protoc_insertion_point(field_mutable_list:city.routing.v2.RoadStatuses.road_statuses)
  return &_impl_.road_statuses_;
}
inline const ::city::routing::v2::RoadStatus& RoadStatuses::_internal_road_statuses(int index) const {
  return _impl_.road_statuses_.Get(index);
}
inline const ::city::routing::v2::RoadStatus& RoadStatuses::road_statuses(int index) const {
  // @@protoc_insertion_point(field_get:city.routing.v2.RoadStatuses.road_statuses)
  return _internal_road_statuses(index);
}
inline ::city::routing::v2::RoadStatus* RoadStatuses::_internal_add_road_statuses() {
  return _impl_.road_statuses_.Add();
}
inline ::city::routing::v2::RoadStatus* RoadStatuses::add_road_statuses() {
  ::city::routing::v2::RoadStatus* _add = _internal_add_road_statuses();
  // @@protoc_insertion_point(field_add:city.routing.v2.RoadStatuses.road_statuses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::routing::v2::RoadStatus >&
RoadStatuses::road_statuses() const {
  // @@protoc_insertion_point(field_list:city.routing.v2.RoadStatuses.road_statuses)
  return _impl_.road_statuses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace routing
}  // namespace city

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::city::routing::v2::RouteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::city::routing::v2::RouteType>() {
  return ::city::routing::v2::RouteType_descriptor();
}
template <> struct is_proto_enum< ::city::routing::v2::JourneyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::city::routing::v2::JourneyType>() {
  return ::city::routing::v2::JourneyType_descriptor();
}
template <> struct is_proto_enum< ::city::routing::v2::MovingDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::city::routing::v2::MovingDirection>() {
  return ::city::routing::v2::MovingDirection_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_city_2frouting_2fv2_2frouting_2eproto

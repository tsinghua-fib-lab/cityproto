// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: city/elec/input/v1/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_city_2felec_2finput_2fv1_2fconfig_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_city_2felec_2finput_2fv1_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "city/config/v1/config.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_city_2felec_2finput_2fv1_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_city_2felec_2finput_2fv1_2fconfig_2eproto;
namespace city {
namespace elec {
namespace input {
namespace v1 {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Control;
struct ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class ControlStep;
struct ControlStepDefaultTypeInternal;
extern ControlStepDefaultTypeInternal _ControlStep_default_instance_;
class Mongo;
struct MongoDefaultTypeInternal;
extern MongoDefaultTypeInternal _Mongo_default_instance_;
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class OutputSwitch;
struct OutputSwitchDefaultTypeInternal;
extern OutputSwitchDefaultTypeInternal _OutputSwitch_default_instance_;
}  // namespace v1
}  // namespace input
}  // namespace elec
}  // namespace city
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace city {
namespace elec {
namespace input {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class Mongo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Mongo) */ {
 public:
  inline Mongo() : Mongo(nullptr) {}
  ~Mongo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mongo(::google::protobuf::internal::ConstantInitialized);

  Mongo(const Mongo& from);
  Mongo(Mongo&& from) noexcept
    : Mongo() {
    *this = ::std::move(from);
  }

  inline Mongo& operator=(const Mongo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mongo& operator=(Mongo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mongo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mongo* internal_default_instance() {
    return reinterpret_cast<const Mongo*>(
               &_Mongo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Mongo& a, Mongo& b) {
    a.Swap(&b);
  }
  inline void Swap(Mongo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mongo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mongo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mongo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mongo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Mongo& from) {
    Mongo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mongo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.elec.input.v1.Mongo";
  }
  protected:
  explicit Mongo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kMapFieldNumber = 2,
    kFacilitiesFieldNumber = 3,
  };
  // string uri = 1 [json_name = "uri"];
  void clear_uri() ;
  const std::string& uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri(Arg_&& arg, Args_... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* ptr);

  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(
      const std::string& value);
  std::string* _internal_mutable_uri();

  public:
  // .city.config.v1.MongoPath map = 2 [json_name = "map"];
  bool has_map() const;
  void clear_map() ;
  const ::city::config::v1::MongoPath& map() const;
  PROTOBUF_NODISCARD ::city::config::v1::MongoPath* release_map();
  ::city::config::v1::MongoPath* mutable_map();
  void set_allocated_map(::city::config::v1::MongoPath* value);
  void unsafe_arena_set_allocated_map(::city::config::v1::MongoPath* value);
  ::city::config::v1::MongoPath* unsafe_arena_release_map();

  private:
  const ::city::config::v1::MongoPath& _internal_map() const;
  ::city::config::v1::MongoPath* _internal_mutable_map();

  public:
  // .city.config.v1.MongoPath facilities = 3 [json_name = "facilities"];
  bool has_facilities() const;
  void clear_facilities() ;
  const ::city::config::v1::MongoPath& facilities() const;
  PROTOBUF_NODISCARD ::city::config::v1::MongoPath* release_facilities();
  ::city::config::v1::MongoPath* mutable_facilities();
  void set_allocated_facilities(::city::config::v1::MongoPath* value);
  void unsafe_arena_set_allocated_facilities(::city::config::v1::MongoPath* value);
  ::city::config::v1::MongoPath* unsafe_arena_release_facilities();

  private:
  const ::city::config::v1::MongoPath& _internal_facilities() const;
  ::city::config::v1::MongoPath* _internal_mutable_facilities();

  public:
  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Mongo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
    ::city::config::v1::MongoPath* map_;
    ::city::config::v1::MongoPath* facilities_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};// -------------------------------------------------------------------

class ControlStep final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.ControlStep) */ {
 public:
  inline ControlStep() : ControlStep(nullptr) {}
  ~ControlStep() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControlStep(::google::protobuf::internal::ConstantInitialized);

  ControlStep(const ControlStep& from);
  ControlStep(ControlStep&& from) noexcept
    : ControlStep() {
    *this = ::std::move(from);
  }

  inline ControlStep& operator=(const ControlStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlStep& operator=(ControlStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlStep* internal_default_instance() {
    return reinterpret_cast<const ControlStep*>(
               &_ControlStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ControlStep& a, ControlStep& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlStep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlStep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControlStep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControlStep& from) {
    ControlStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlStep* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.elec.input.v1.ControlStep";
  }
  protected:
  explicit ControlStep(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // int32 start = 1 [json_name = "start"];
  void clear_start() ;
  ::int32_t start() const;
  void set_start(::int32_t value);

  private:
  ::int32_t _internal_start() const;
  void _internal_set_start(::int32_t value);

  public:
  // int32 total = 2 [json_name = "total"];
  void clear_total() ;
  ::int32_t total() const;
  void set_total(::int32_t value);

  private:
  ::int32_t _internal_total() const;
  void _internal_set_total(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:city.elec.input.v1.ControlStep)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t start_;
    ::int32_t total_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Control final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Control) */ {
 public:
  inline Control() : Control(nullptr) {}
  ~Control() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Control(::google::protobuf::internal::ConstantInitialized);

  Control(const Control& from);
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control& operator=(Control&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }
  inline void Swap(Control* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Control* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Control& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Control& from) {
    Control::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.elec.input.v1.Control";
  }
  protected:
  explicit Control(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
  };
  // .city.elec.input.v1.ControlStep step = 1 [json_name = "step"];
  bool has_step() const;
  void clear_step() ;
  const ::city::elec::input::v1::ControlStep& step() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::ControlStep* release_step();
  ::city::elec::input::v1::ControlStep* mutable_step();
  void set_allocated_step(::city::elec::input::v1::ControlStep* value);
  void unsafe_arena_set_allocated_step(::city::elec::input::v1::ControlStep* value);
  ::city::elec::input::v1::ControlStep* unsafe_arena_release_step();

  private:
  const ::city::elec::input::v1::ControlStep& _internal_step() const;
  ::city::elec::input::v1::ControlStep* _internal_mutable_step();

  public:
  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Control)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::elec::input::v1::ControlStep* step_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};// -------------------------------------------------------------------

class OutputSwitch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.OutputSwitch) */ {
 public:
  inline OutputSwitch() : OutputSwitch(nullptr) {}
  ~OutputSwitch() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OutputSwitch(::google::protobuf::internal::ConstantInitialized);

  OutputSwitch(const OutputSwitch& from);
  OutputSwitch(OutputSwitch&& from) noexcept
    : OutputSwitch() {
    *this = ::std::move(from);
  }

  inline OutputSwitch& operator=(const OutputSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputSwitch& operator=(OutputSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputSwitch* internal_default_instance() {
    return reinterpret_cast<const OutputSwitch*>(
               &_OutputSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OutputSwitch& a, OutputSwitch& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputSwitch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputSwitch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputSwitch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputSwitch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OutputSwitch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OutputSwitch& from) {
    OutputSwitch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputSwitch* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.elec.input.v1.OutputSwitch";
  }
  protected:
  explicit OutputSwitch(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kAoiFieldNumber = 2,
    kEventFieldNumber = 3,
  };
  // bool node = 1 [json_name = "node"];
  void clear_node() ;
  bool node() const;
  void set_node(bool value);

  private:
  bool _internal_node() const;
  void _internal_set_node(bool value);

  public:
  // bool aoi = 2 [json_name = "aoi"];
  void clear_aoi() ;
  bool aoi() const;
  void set_aoi(bool value);

  private:
  bool _internal_aoi() const;
  void _internal_set_aoi(bool value);

  public:
  // bool event = 3 [json_name = "event"];
  void clear_event() ;
  bool event() const;
  void set_event(bool value);

  private:
  bool _internal_event() const;
  void _internal_set_event(bool value);

  public:
  // @@protoc_insertion_point(class_scope:city.elec.input.v1.OutputSwitch)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool node_;
    bool aoi_;
    bool event_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Output final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Output(::google::protobuf::internal::ConstantInitialized);

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Output& from) {
    Output::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.elec.input.v1.Output";
  }
  protected:
  explicit Output(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
    kSwitchFieldNumber = 2,
  };
  // .city.config.v1.OutputTarget target = 1 [json_name = "target"];
  bool has_target() const;
  void clear_target() ;
  const ::city::config::v1::OutputTarget& target() const;
  PROTOBUF_NODISCARD ::city::config::v1::OutputTarget* release_target();
  ::city::config::v1::OutputTarget* mutable_target();
  void set_allocated_target(::city::config::v1::OutputTarget* value);
  void unsafe_arena_set_allocated_target(::city::config::v1::OutputTarget* value);
  ::city::config::v1::OutputTarget* unsafe_arena_release_target();

  private:
  const ::city::config::v1::OutputTarget& _internal_target() const;
  ::city::config::v1::OutputTarget* _internal_mutable_target();

  public:
  // .city.elec.input.v1.OutputSwitch switch = 2 [json_name = "switch"];
  bool has_switch_() const;
  void clear_switch_() ;
  const ::city::elec::input::v1::OutputSwitch& switch_() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::OutputSwitch* release_switch_();
  ::city::elec::input::v1::OutputSwitch* mutable_switch_();
  void set_allocated_switch_(::city::elec::input::v1::OutputSwitch* value);
  void unsafe_arena_set_allocated_switch_(::city::elec::input::v1::OutputSwitch* value);
  ::city::elec::input::v1::OutputSwitch* unsafe_arena_release_switch_();

  private:
  const ::city::elec::input::v1::OutputSwitch& _internal_switch_() const;
  ::city::elec::input::v1::OutputSwitch* _internal_mutable_switch_();

  public:
  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Output)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::config::v1::OutputTarget* target_;
    ::city::elec::input::v1::OutputSwitch* switch__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};// -------------------------------------------------------------------

class Config final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Config(::google::protobuf::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.elec.input.v1.Config";
  }
  protected:
  explicit Config(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMongoFieldNumber = 1,
    kControlFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // .city.elec.input.v1.Mongo mongo = 1 [json_name = "mongo"];
  bool has_mongo() const;
  void clear_mongo() ;
  const ::city::elec::input::v1::Mongo& mongo() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::Mongo* release_mongo();
  ::city::elec::input::v1::Mongo* mutable_mongo();
  void set_allocated_mongo(::city::elec::input::v1::Mongo* value);
  void unsafe_arena_set_allocated_mongo(::city::elec::input::v1::Mongo* value);
  ::city::elec::input::v1::Mongo* unsafe_arena_release_mongo();

  private:
  const ::city::elec::input::v1::Mongo& _internal_mongo() const;
  ::city::elec::input::v1::Mongo* _internal_mutable_mongo();

  public:
  // .city.elec.input.v1.Control control = 2 [json_name = "control"];
  bool has_control() const;
  void clear_control() ;
  const ::city::elec::input::v1::Control& control() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::Control* release_control();
  ::city::elec::input::v1::Control* mutable_control();
  void set_allocated_control(::city::elec::input::v1::Control* value);
  void unsafe_arena_set_allocated_control(::city::elec::input::v1::Control* value);
  ::city::elec::input::v1::Control* unsafe_arena_release_control();

  private:
  const ::city::elec::input::v1::Control& _internal_control() const;
  ::city::elec::input::v1::Control* _internal_mutable_control();

  public:
  // .city.elec.input.v1.Output output = 3 [json_name = "output"];
  bool has_output() const;
  void clear_output() ;
  const ::city::elec::input::v1::Output& output() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::Output* release_output();
  ::city::elec::input::v1::Output* mutable_output();
  void set_allocated_output(::city::elec::input::v1::Output* value);
  void unsafe_arena_set_allocated_output(::city::elec::input::v1::Output* value);
  ::city::elec::input::v1::Output* unsafe_arena_release_output();

  private:
  const ::city::elec::input::v1::Output& _internal_output() const;
  ::city::elec::input::v1::Output* _internal_mutable_output();

  public:
  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Config)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::elec::input::v1::Mongo* mongo_;
    ::city::elec::input::v1::Control* control_;
    ::city::elec::input::v1::Output* output_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Mongo

// string uri = 1 [json_name = "uri"];
inline void Mongo::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Mongo::uri() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Mongo.uri)
  return _internal_uri();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Mongo::set_uri(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uri_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:city.elec.input.v1.Mongo.uri)
}
inline std::string* Mongo::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Mongo.uri)
  return _s;
}
inline const std::string& Mongo::_internal_uri() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uri_.Get();
}
inline void Mongo::_internal_set_uri(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Mongo::_internal_mutable_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.uri_.Mutable( GetArenaForAllocation());
}
inline std::string* Mongo::release_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Mongo.uri)
  return _impl_.uri_.Release();
}
inline void Mongo::set_allocated_uri(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uri_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uri_.IsDefault()) {
          _impl_.uri_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Mongo.uri)
}

// .city.config.v1.MongoPath map = 2 [json_name = "map"];
inline bool Mongo::has_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.map_ != nullptr);
  return value;
}
inline const ::city::config::v1::MongoPath& Mongo::_internal_map() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::config::v1::MongoPath* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::config::v1::MongoPath&>(::city::config::v1::_MongoPath_default_instance_);
}
inline const ::city::config::v1::MongoPath& Mongo::map() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Mongo.map)
  return _internal_map();
}
inline void Mongo::unsafe_arena_set_allocated_map(::city::config::v1::MongoPath* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = reinterpret_cast<::city::config::v1::MongoPath*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Mongo.map)
}
inline ::city::config::v1::MongoPath* Mongo::release_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::config::v1::MongoPath* released = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::config::v1::MongoPath* Mongo::unsafe_arena_release_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Mongo.map)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::config::v1::MongoPath* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::city::config::v1::MongoPath* Mongo::_internal_mutable_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::config::v1::MongoPath>(GetArenaForAllocation());
    _impl_.map_ = reinterpret_cast<::city::config::v1::MongoPath*>(p);
  }
  return _impl_.map_;
}
inline ::city::config::v1::MongoPath* Mongo::mutable_map() {
  ::city::config::v1::MongoPath* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Mongo.map)
  return _msg;
}
inline void Mongo::set_allocated_map(::city::config::v1::MongoPath* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.map_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.map_ = reinterpret_cast<::city::config::v1::MongoPath*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Mongo.map)
}

// .city.config.v1.MongoPath facilities = 3 [json_name = "facilities"];
inline bool Mongo::has_facilities() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.facilities_ != nullptr);
  return value;
}
inline const ::city::config::v1::MongoPath& Mongo::_internal_facilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::config::v1::MongoPath* p = _impl_.facilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::config::v1::MongoPath&>(::city::config::v1::_MongoPath_default_instance_);
}
inline const ::city::config::v1::MongoPath& Mongo::facilities() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Mongo.facilities)
  return _internal_facilities();
}
inline void Mongo::unsafe_arena_set_allocated_facilities(::city::config::v1::MongoPath* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.facilities_);
  }
  _impl_.facilities_ = reinterpret_cast<::city::config::v1::MongoPath*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Mongo.facilities)
}
inline ::city::config::v1::MongoPath* Mongo::release_facilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::config::v1::MongoPath* released = _impl_.facilities_;
  _impl_.facilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::config::v1::MongoPath* Mongo::unsafe_arena_release_facilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Mongo.facilities)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::config::v1::MongoPath* temp = _impl_.facilities_;
  _impl_.facilities_ = nullptr;
  return temp;
}
inline ::city::config::v1::MongoPath* Mongo::_internal_mutable_facilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.facilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::config::v1::MongoPath>(GetArenaForAllocation());
    _impl_.facilities_ = reinterpret_cast<::city::config::v1::MongoPath*>(p);
  }
  return _impl_.facilities_;
}
inline ::city::config::v1::MongoPath* Mongo::mutable_facilities() {
  ::city::config::v1::MongoPath* _msg = _internal_mutable_facilities();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Mongo.facilities)
  return _msg;
}
inline void Mongo::set_allocated_facilities(::city::config::v1::MongoPath* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.facilities_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.facilities_ = reinterpret_cast<::city::config::v1::MongoPath*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Mongo.facilities)
}

// -------------------------------------------------------------------

// ControlStep

// int32 start = 1 [json_name = "start"];
inline void ControlStep::clear_start() {
  _impl_.start_ = 0;
}
inline ::int32_t ControlStep::start() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.ControlStep.start)
  return _internal_start();
}
inline void ControlStep::set_start(::int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.ControlStep.start)
}
inline ::int32_t ControlStep::_internal_start() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_;
}
inline void ControlStep::_internal_set_start(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_ = value;
}

// int32 total = 2 [json_name = "total"];
inline void ControlStep::clear_total() {
  _impl_.total_ = 0;
}
inline ::int32_t ControlStep::total() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.ControlStep.total)
  return _internal_total();
}
inline void ControlStep::set_total(::int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.ControlStep.total)
}
inline ::int32_t ControlStep::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void ControlStep::_internal_set_total(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_ = value;
}

// -------------------------------------------------------------------

// Control

// .city.elec.input.v1.ControlStep step = 1 [json_name = "step"];
inline bool Control::has_step() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.step_ != nullptr);
  return value;
}
inline void Control::clear_step() {
  if (_impl_.step_ != nullptr) _impl_.step_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::city::elec::input::v1::ControlStep& Control::_internal_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::elec::input::v1::ControlStep* p = _impl_.step_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::ControlStep&>(::city::elec::input::v1::_ControlStep_default_instance_);
}
inline const ::city::elec::input::v1::ControlStep& Control::step() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Control.step)
  return _internal_step();
}
inline void Control::unsafe_arena_set_allocated_step(::city::elec::input::v1::ControlStep* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.step_);
  }
  _impl_.step_ = reinterpret_cast<::city::elec::input::v1::ControlStep*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Control.step)
}
inline ::city::elec::input::v1::ControlStep* Control::release_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::elec::input::v1::ControlStep* released = _impl_.step_;
  _impl_.step_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::elec::input::v1::ControlStep* Control::unsafe_arena_release_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Control.step)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::elec::input::v1::ControlStep* temp = _impl_.step_;
  _impl_.step_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::ControlStep* Control::_internal_mutable_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.step_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::ControlStep>(GetArenaForAllocation());
    _impl_.step_ = reinterpret_cast<::city::elec::input::v1::ControlStep*>(p);
  }
  return _impl_.step_;
}
inline ::city::elec::input::v1::ControlStep* Control::mutable_step() {
  ::city::elec::input::v1::ControlStep* _msg = _internal_mutable_step();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Control.step)
  return _msg;
}
inline void Control::set_allocated_step(::city::elec::input::v1::ControlStep* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::elec::input::v1::ControlStep*>(_impl_.step_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::elec::input::v1::ControlStep*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.step_ = reinterpret_cast<::city::elec::input::v1::ControlStep*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Control.step)
}

// -------------------------------------------------------------------

// OutputSwitch

// bool node = 1 [json_name = "node"];
inline void OutputSwitch::clear_node() {
  _impl_.node_ = false;
}
inline bool OutputSwitch::node() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.OutputSwitch.node)
  return _internal_node();
}
inline void OutputSwitch::set_node(bool value) {
  _internal_set_node(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.OutputSwitch.node)
}
inline bool OutputSwitch::_internal_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_;
}
inline void OutputSwitch::_internal_set_node(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_ = value;
}

// bool aoi = 2 [json_name = "aoi"];
inline void OutputSwitch::clear_aoi() {
  _impl_.aoi_ = false;
}
inline bool OutputSwitch::aoi() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.OutputSwitch.aoi)
  return _internal_aoi();
}
inline void OutputSwitch::set_aoi(bool value) {
  _internal_set_aoi(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.OutputSwitch.aoi)
}
inline bool OutputSwitch::_internal_aoi() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aoi_;
}
inline void OutputSwitch::_internal_set_aoi(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aoi_ = value;
}

// bool event = 3 [json_name = "event"];
inline void OutputSwitch::clear_event() {
  _impl_.event_ = false;
}
inline bool OutputSwitch::event() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.OutputSwitch.event)
  return _internal_event();
}
inline void OutputSwitch::set_event(bool value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.OutputSwitch.event)
}
inline bool OutputSwitch::_internal_event() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_;
}
inline void OutputSwitch::_internal_set_event(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.event_ = value;
}

// -------------------------------------------------------------------

// Output

// .city.config.v1.OutputTarget target = 1 [json_name = "target"];
inline bool Output::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline const ::city::config::v1::OutputTarget& Output::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::config::v1::OutputTarget* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::config::v1::OutputTarget&>(::city::config::v1::_OutputTarget_default_instance_);
}
inline const ::city::config::v1::OutputTarget& Output::target() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Output.target)
  return _internal_target();
}
inline void Output::unsafe_arena_set_allocated_target(::city::config::v1::OutputTarget* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::city::config::v1::OutputTarget*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Output.target)
}
inline ::city::config::v1::OutputTarget* Output::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::config::v1::OutputTarget* released = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::config::v1::OutputTarget* Output::unsafe_arena_release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Output.target)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::config::v1::OutputTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::city::config::v1::OutputTarget* Output::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::config::v1::OutputTarget>(GetArenaForAllocation());
    _impl_.target_ = reinterpret_cast<::city::config::v1::OutputTarget*>(p);
  }
  return _impl_.target_;
}
inline ::city::config::v1::OutputTarget* Output::mutable_target() {
  ::city::config::v1::OutputTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Output.target)
  return _msg;
}
inline void Output::set_allocated_target(::city::config::v1::OutputTarget* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_ = reinterpret_cast<::city::config::v1::OutputTarget*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Output.target)
}

// .city.elec.input.v1.OutputSwitch switch = 2 [json_name = "switch"];
inline bool Output::has_switch_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.switch__ != nullptr);
  return value;
}
inline void Output::clear_switch_() {
  if (_impl_.switch__ != nullptr) _impl_.switch__->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::city::elec::input::v1::OutputSwitch& Output::_internal_switch_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::elec::input::v1::OutputSwitch* p = _impl_.switch__;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::OutputSwitch&>(::city::elec::input::v1::_OutputSwitch_default_instance_);
}
inline const ::city::elec::input::v1::OutputSwitch& Output::switch_() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Output.switch)
  return _internal_switch_();
}
inline void Output::unsafe_arena_set_allocated_switch_(::city::elec::input::v1::OutputSwitch* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.switch__);
  }
  _impl_.switch__ = reinterpret_cast<::city::elec::input::v1::OutputSwitch*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Output.switch)
}
inline ::city::elec::input::v1::OutputSwitch* Output::release_switch_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::elec::input::v1::OutputSwitch* released = _impl_.switch__;
  _impl_.switch__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::elec::input::v1::OutputSwitch* Output::unsafe_arena_release_switch_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Output.switch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::elec::input::v1::OutputSwitch* temp = _impl_.switch__;
  _impl_.switch__ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::OutputSwitch* Output::_internal_mutable_switch_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.switch__ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::OutputSwitch>(GetArenaForAllocation());
    _impl_.switch__ = reinterpret_cast<::city::elec::input::v1::OutputSwitch*>(p);
  }
  return _impl_.switch__;
}
inline ::city::elec::input::v1::OutputSwitch* Output::mutable_switch_() {
  ::city::elec::input::v1::OutputSwitch* _msg = _internal_mutable_switch_();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Output.switch)
  return _msg;
}
inline void Output::set_allocated_switch_(::city::elec::input::v1::OutputSwitch* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::elec::input::v1::OutputSwitch*>(_impl_.switch__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::elec::input::v1::OutputSwitch*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.switch__ = reinterpret_cast<::city::elec::input::v1::OutputSwitch*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Output.switch)
}

// -------------------------------------------------------------------

// Config

// .city.elec.input.v1.Mongo mongo = 1 [json_name = "mongo"];
inline bool Config::has_mongo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mongo_ != nullptr);
  return value;
}
inline void Config::clear_mongo() {
  if (_impl_.mongo_ != nullptr) _impl_.mongo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::city::elec::input::v1::Mongo& Config::_internal_mongo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::elec::input::v1::Mongo* p = _impl_.mongo_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::Mongo&>(::city::elec::input::v1::_Mongo_default_instance_);
}
inline const ::city::elec::input::v1::Mongo& Config::mongo() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Config.mongo)
  return _internal_mongo();
}
inline void Config::unsafe_arena_set_allocated_mongo(::city::elec::input::v1::Mongo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mongo_);
  }
  _impl_.mongo_ = reinterpret_cast<::city::elec::input::v1::Mongo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Config.mongo)
}
inline ::city::elec::input::v1::Mongo* Config::release_mongo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::elec::input::v1::Mongo* released = _impl_.mongo_;
  _impl_.mongo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::elec::input::v1::Mongo* Config::unsafe_arena_release_mongo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Config.mongo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::elec::input::v1::Mongo* temp = _impl_.mongo_;
  _impl_.mongo_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::Mongo* Config::_internal_mutable_mongo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.mongo_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::Mongo>(GetArenaForAllocation());
    _impl_.mongo_ = reinterpret_cast<::city::elec::input::v1::Mongo*>(p);
  }
  return _impl_.mongo_;
}
inline ::city::elec::input::v1::Mongo* Config::mutable_mongo() {
  ::city::elec::input::v1::Mongo* _msg = _internal_mutable_mongo();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Config.mongo)
  return _msg;
}
inline void Config::set_allocated_mongo(::city::elec::input::v1::Mongo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::elec::input::v1::Mongo*>(_impl_.mongo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::elec::input::v1::Mongo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mongo_ = reinterpret_cast<::city::elec::input::v1::Mongo*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Config.mongo)
}

// .city.elec.input.v1.Control control = 2 [json_name = "control"];
inline bool Config::has_control() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_ != nullptr);
  return value;
}
inline void Config::clear_control() {
  if (_impl_.control_ != nullptr) _impl_.control_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::city::elec::input::v1::Control& Config::_internal_control() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::elec::input::v1::Control* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::Control&>(::city::elec::input::v1::_Control_default_instance_);
}
inline const ::city::elec::input::v1::Control& Config::control() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Config.control)
  return _internal_control();
}
inline void Config::unsafe_arena_set_allocated_control(::city::elec::input::v1::Control* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = reinterpret_cast<::city::elec::input::v1::Control*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Config.control)
}
inline ::city::elec::input::v1::Control* Config::release_control() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::elec::input::v1::Control* released = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::elec::input::v1::Control* Config::unsafe_arena_release_control() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Config.control)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::elec::input::v1::Control* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::Control* Config::_internal_mutable_control() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::Control>(GetArenaForAllocation());
    _impl_.control_ = reinterpret_cast<::city::elec::input::v1::Control*>(p);
  }
  return _impl_.control_;
}
inline ::city::elec::input::v1::Control* Config::mutable_control() {
  ::city::elec::input::v1::Control* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Config.control)
  return _msg;
}
inline void Config::set_allocated_control(::city::elec::input::v1::Control* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::elec::input::v1::Control*>(_impl_.control_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::elec::input::v1::Control*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.control_ = reinterpret_cast<::city::elec::input::v1::Control*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Config.control)
}

// .city.elec.input.v1.Output output = 3 [json_name = "output"];
inline bool Config::has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline void Config::clear_output() {
  if (_impl_.output_ != nullptr) _impl_.output_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::city::elec::input::v1::Output& Config::_internal_output() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::elec::input::v1::Output* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::Output&>(::city::elec::input::v1::_Output_default_instance_);
}
inline const ::city::elec::input::v1::Output& Config::output() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Config.output)
  return _internal_output();
}
inline void Config::unsafe_arena_set_allocated_output(::city::elec::input::v1::Output* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = reinterpret_cast<::city::elec::input::v1::Output*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Config.output)
}
inline ::city::elec::input::v1::Output* Config::release_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::elec::input::v1::Output* released = _impl_.output_;
  _impl_.output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::elec::input::v1::Output* Config::unsafe_arena_release_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Config.output)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::elec::input::v1::Output* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::Output* Config::_internal_mutable_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.output_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::Output>(GetArenaForAllocation());
    _impl_.output_ = reinterpret_cast<::city::elec::input::v1::Output*>(p);
  }
  return _impl_.output_;
}
inline ::city::elec::input::v1::Output* Config::mutable_output() {
  ::city::elec::input::v1::Output* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Config.output)
  return _msg;
}
inline void Config::set_allocated_output(::city::elec::input::v1::Output* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::elec::input::v1::Output*>(_impl_.output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::elec::input::v1::Output*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.output_ = reinterpret_cast<::city::elec::input::v1::Output*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Config.output)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace input
}  // namespace elec
}  // namespace city


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_city_2felec_2finput_2fv1_2fconfig_2eproto_2epb_2eh

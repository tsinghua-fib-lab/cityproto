// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: city/elec/input/v1/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_city_2felec_2finput_2fv1_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_city_2felec_2finput_2fv1_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "city/config/v1/config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_city_2felec_2finput_2fv1_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_city_2felec_2finput_2fv1_2fconfig_2eproto;
namespace city {
namespace elec {
namespace input {
namespace v1 {
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Control;
struct ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class ControlStep;
struct ControlStepDefaultTypeInternal;
extern ControlStepDefaultTypeInternal _ControlStep_default_instance_;
class Mongo;
struct MongoDefaultTypeInternal;
extern MongoDefaultTypeInternal _Mongo_default_instance_;
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class OutputSwitch;
struct OutputSwitchDefaultTypeInternal;
extern OutputSwitchDefaultTypeInternal _OutputSwitch_default_instance_;
}  // namespace v1
}  // namespace input
}  // namespace elec
}  // namespace city
PROTOBUF_NAMESPACE_OPEN
template<> ::city::elec::input::v1::Config* Arena::CreateMaybeMessage<::city::elec::input::v1::Config>(Arena*);
template<> ::city::elec::input::v1::Control* Arena::CreateMaybeMessage<::city::elec::input::v1::Control>(Arena*);
template<> ::city::elec::input::v1::ControlStep* Arena::CreateMaybeMessage<::city::elec::input::v1::ControlStep>(Arena*);
template<> ::city::elec::input::v1::Mongo* Arena::CreateMaybeMessage<::city::elec::input::v1::Mongo>(Arena*);
template<> ::city::elec::input::v1::Output* Arena::CreateMaybeMessage<::city::elec::input::v1::Output>(Arena*);
template<> ::city::elec::input::v1::OutputSwitch* Arena::CreateMaybeMessage<::city::elec::input::v1::OutputSwitch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace city {
namespace elec {
namespace input {
namespace v1 {

// ===================================================================

class Mongo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Mongo) */ {
 public:
  inline Mongo() : Mongo(nullptr) {}
  ~Mongo() override;
  explicit PROTOBUF_CONSTEXPR Mongo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mongo(const Mongo& from);
  Mongo(Mongo&& from) noexcept
    : Mongo() {
    *this = ::std::move(from);
  }

  inline Mongo& operator=(const Mongo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mongo& operator=(Mongo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mongo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mongo* internal_default_instance() {
    return reinterpret_cast<const Mongo*>(
               &_Mongo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Mongo& a, Mongo& b) {
    a.Swap(&b);
  }
  inline void Swap(Mongo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mongo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mongo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mongo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mongo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mongo& from) {
    Mongo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mongo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.elec.input.v1.Mongo";
  }
  protected:
  explicit Mongo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kMapFieldNumber = 2,
    kFacilitiesFieldNumber = 3,
  };
  // string uri = 1 [json_name = "uri"];
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // .city.config.v1.MongoPath map = 2 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const ::city::config::v1::MongoPath& map() const;
  PROTOBUF_NODISCARD ::city::config::v1::MongoPath* release_map();
  ::city::config::v1::MongoPath* mutable_map();
  void set_allocated_map(::city::config::v1::MongoPath* map);
  private:
  const ::city::config::v1::MongoPath& _internal_map() const;
  ::city::config::v1::MongoPath* _internal_mutable_map();
  public:
  void unsafe_arena_set_allocated_map(
      ::city::config::v1::MongoPath* map);
  ::city::config::v1::MongoPath* unsafe_arena_release_map();

  // .city.config.v1.MongoPath facilities = 3 [json_name = "facilities"];
  bool has_facilities() const;
  private:
  bool _internal_has_facilities() const;
  public:
  void clear_facilities();
  const ::city::config::v1::MongoPath& facilities() const;
  PROTOBUF_NODISCARD ::city::config::v1::MongoPath* release_facilities();
  ::city::config::v1::MongoPath* mutable_facilities();
  void set_allocated_facilities(::city::config::v1::MongoPath* facilities);
  private:
  const ::city::config::v1::MongoPath& _internal_facilities() const;
  ::city::config::v1::MongoPath* _internal_mutable_facilities();
  public:
  void unsafe_arena_set_allocated_facilities(
      ::city::config::v1::MongoPath* facilities);
  ::city::config::v1::MongoPath* unsafe_arena_release_facilities();

  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Mongo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::city::config::v1::MongoPath* map_;
    ::city::config::v1::MongoPath* facilities_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ControlStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.ControlStep) */ {
 public:
  inline ControlStep() : ControlStep(nullptr) {}
  ~ControlStep() override;
  explicit PROTOBUF_CONSTEXPR ControlStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlStep(const ControlStep& from);
  ControlStep(ControlStep&& from) noexcept
    : ControlStep() {
    *this = ::std::move(from);
  }

  inline ControlStep& operator=(const ControlStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlStep& operator=(ControlStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlStep* internal_default_instance() {
    return reinterpret_cast<const ControlStep*>(
               &_ControlStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ControlStep& a, ControlStep& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlStep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlStep& from) {
    ControlStep::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlStep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.elec.input.v1.ControlStep";
  }
  protected:
  explicit ControlStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // int32 start = 1 [json_name = "start"];
  void clear_start();
  int32_t start() const;
  void set_start(int32_t value);
  private:
  int32_t _internal_start() const;
  void _internal_set_start(int32_t value);
  public:

  // int32 total = 2 [json_name = "total"];
  void clear_total();
  int32_t total() const;
  void set_total(int32_t value);
  private:
  int32_t _internal_total() const;
  void _internal_set_total(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:city.elec.input.v1.ControlStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t start_;
    int32_t total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Control final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Control) */ {
 public:
  inline Control() : Control(nullptr) {}
  ~Control() override;
  explicit PROTOBUF_CONSTEXPR Control(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control(const Control& from);
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control& operator=(Control&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }
  inline void Swap(Control* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Control& from) {
    Control::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.elec.input.v1.Control";
  }
  protected:
  explicit Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
  };
  // .city.elec.input.v1.ControlStep step = 1 [json_name = "step"];
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  const ::city::elec::input::v1::ControlStep& step() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::ControlStep* release_step();
  ::city::elec::input::v1::ControlStep* mutable_step();
  void set_allocated_step(::city::elec::input::v1::ControlStep* step);
  private:
  const ::city::elec::input::v1::ControlStep& _internal_step() const;
  ::city::elec::input::v1::ControlStep* _internal_mutable_step();
  public:
  void unsafe_arena_set_allocated_step(
      ::city::elec::input::v1::ControlStep* step);
  ::city::elec::input::v1::ControlStep* unsafe_arena_release_step();

  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Control)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::city::elec::input::v1::ControlStep* step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class OutputSwitch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.OutputSwitch) */ {
 public:
  inline OutputSwitch() : OutputSwitch(nullptr) {}
  ~OutputSwitch() override;
  explicit PROTOBUF_CONSTEXPR OutputSwitch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OutputSwitch(const OutputSwitch& from);
  OutputSwitch(OutputSwitch&& from) noexcept
    : OutputSwitch() {
    *this = ::std::move(from);
  }

  inline OutputSwitch& operator=(const OutputSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputSwitch& operator=(OutputSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OutputSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutputSwitch* internal_default_instance() {
    return reinterpret_cast<const OutputSwitch*>(
               &_OutputSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OutputSwitch& a, OutputSwitch& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputSwitch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutputSwitch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutputSwitch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutputSwitch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OutputSwitch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OutputSwitch& from) {
    OutputSwitch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputSwitch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.elec.input.v1.OutputSwitch";
  }
  protected:
  explicit OutputSwitch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kAoiFieldNumber = 2,
    kEventFieldNumber = 3,
  };
  // bool node = 1 [json_name = "node"];
  void clear_node();
  bool node() const;
  void set_node(bool value);
  private:
  bool _internal_node() const;
  void _internal_set_node(bool value);
  public:

  // bool aoi = 2 [json_name = "aoi"];
  void clear_aoi();
  bool aoi() const;
  void set_aoi(bool value);
  private:
  bool _internal_aoi() const;
  void _internal_set_aoi(bool value);
  public:

  // bool event = 3 [json_name = "event"];
  void clear_event();
  bool event() const;
  void set_event(bool value);
  private:
  bool _internal_event() const;
  void _internal_set_event(bool value);
  public:

  // @@protoc_insertion_point(class_scope:city.elec.input.v1.OutputSwitch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool node_;
    bool aoi_;
    bool event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Output final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  explicit PROTOBUF_CONSTEXPR Output(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Output& from) {
    Output::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.elec.input.v1.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
    kSwitchFieldNumber = 2,
  };
  // .city.config.v1.OutputTarget target = 1 [json_name = "target"];
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::city::config::v1::OutputTarget& target() const;
  PROTOBUF_NODISCARD ::city::config::v1::OutputTarget* release_target();
  ::city::config::v1::OutputTarget* mutable_target();
  void set_allocated_target(::city::config::v1::OutputTarget* target);
  private:
  const ::city::config::v1::OutputTarget& _internal_target() const;
  ::city::config::v1::OutputTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::city::config::v1::OutputTarget* target);
  ::city::config::v1::OutputTarget* unsafe_arena_release_target();

  // .city.elec.input.v1.OutputSwitch switch = 2 [json_name = "switch"];
  bool has_switch_() const;
  private:
  bool _internal_has_switch_() const;
  public:
  void clear_switch_();
  const ::city::elec::input::v1::OutputSwitch& switch_() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::OutputSwitch* release_switch_();
  ::city::elec::input::v1::OutputSwitch* mutable_switch_();
  void set_allocated_switch_(::city::elec::input::v1::OutputSwitch* switch_);
  private:
  const ::city::elec::input::v1::OutputSwitch& _internal_switch_() const;
  ::city::elec::input::v1::OutputSwitch* _internal_mutable_switch_();
  public:
  void unsafe_arena_set_allocated_switch_(
      ::city::elec::input::v1::OutputSwitch* switch_);
  ::city::elec::input::v1::OutputSwitch* unsafe_arena_release_switch_();

  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Output)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::city::config::v1::OutputTarget* target_;
    ::city::elec::input::v1::OutputSwitch* switch__;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.elec.input.v1.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit PROTOBUF_CONSTEXPR Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Config& from) {
    Config::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.elec.input.v1.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMongoFieldNumber = 1,
    kControlFieldNumber = 2,
    kOutputFieldNumber = 3,
  };
  // .city.elec.input.v1.Mongo mongo = 1 [json_name = "mongo"];
  bool has_mongo() const;
  private:
  bool _internal_has_mongo() const;
  public:
  void clear_mongo();
  const ::city::elec::input::v1::Mongo& mongo() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::Mongo* release_mongo();
  ::city::elec::input::v1::Mongo* mutable_mongo();
  void set_allocated_mongo(::city::elec::input::v1::Mongo* mongo);
  private:
  const ::city::elec::input::v1::Mongo& _internal_mongo() const;
  ::city::elec::input::v1::Mongo* _internal_mutable_mongo();
  public:
  void unsafe_arena_set_allocated_mongo(
      ::city::elec::input::v1::Mongo* mongo);
  ::city::elec::input::v1::Mongo* unsafe_arena_release_mongo();

  // .city.elec.input.v1.Control control = 2 [json_name = "control"];
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::city::elec::input::v1::Control& control() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::Control* release_control();
  ::city::elec::input::v1::Control* mutable_control();
  void set_allocated_control(::city::elec::input::v1::Control* control);
  private:
  const ::city::elec::input::v1::Control& _internal_control() const;
  ::city::elec::input::v1::Control* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::city::elec::input::v1::Control* control);
  ::city::elec::input::v1::Control* unsafe_arena_release_control();

  // .city.elec.input.v1.Output output = 3 [json_name = "output"];
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::city::elec::input::v1::Output& output() const;
  PROTOBUF_NODISCARD ::city::elec::input::v1::Output* release_output();
  ::city::elec::input::v1::Output* mutable_output();
  void set_allocated_output(::city::elec::input::v1::Output* output);
  private:
  const ::city::elec::input::v1::Output& _internal_output() const;
  ::city::elec::input::v1::Output* _internal_mutable_output();
  public:
  void unsafe_arena_set_allocated_output(
      ::city::elec::input::v1::Output* output);
  ::city::elec::input::v1::Output* unsafe_arena_release_output();

  // @@protoc_insertion_point(class_scope:city.elec.input.v1.Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::city::elec::input::v1::Mongo* mongo_;
    ::city::elec::input::v1::Control* control_;
    ::city::elec::input::v1::Output* output_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2felec_2finput_2fv1_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Mongo

// string uri = 1 [json_name = "uri"];
inline void Mongo::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Mongo::uri() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Mongo.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mongo::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:city.elec.input.v1.Mongo.uri)
}
inline std::string* Mongo::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Mongo.uri)
  return _s;
}
inline const std::string& Mongo::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Mongo::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Mongo::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Mongo::release_uri() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Mongo.uri)
  return _impl_.uri_.Release();
}
inline void Mongo::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Mongo.uri)
}

// .city.config.v1.MongoPath map = 2 [json_name = "map"];
inline bool Mongo::_internal_has_map() const {
  return this != internal_default_instance() && _impl_.map_ != nullptr;
}
inline bool Mongo::has_map() const {
  return _internal_has_map();
}
inline const ::city::config::v1::MongoPath& Mongo::_internal_map() const {
  const ::city::config::v1::MongoPath* p = _impl_.map_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::config::v1::MongoPath&>(
      ::city::config::v1::_MongoPath_default_instance_);
}
inline const ::city::config::v1::MongoPath& Mongo::map() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Mongo.map)
  return _internal_map();
}
inline void Mongo::unsafe_arena_set_allocated_map(
    ::city::config::v1::MongoPath* map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  _impl_.map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Mongo.map)
}
inline ::city::config::v1::MongoPath* Mongo::release_map() {
  
  ::city::config::v1::MongoPath* temp = _impl_.map_;
  _impl_.map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::config::v1::MongoPath* Mongo::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Mongo.map)
  
  ::city::config::v1::MongoPath* temp = _impl_.map_;
  _impl_.map_ = nullptr;
  return temp;
}
inline ::city::config::v1::MongoPath* Mongo::_internal_mutable_map() {
  
  if (_impl_.map_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::config::v1::MongoPath>(GetArenaForAllocation());
    _impl_.map_ = p;
  }
  return _impl_.map_;
}
inline ::city::config::v1::MongoPath* Mongo::mutable_map() {
  ::city::config::v1::MongoPath* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Mongo.map)
  return _msg;
}
inline void Mongo::set_allocated_map(::city::config::v1::MongoPath* map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.map_);
  }
  if (map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(map));
    if (message_arena != submessage_arena) {
      map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.map_ = map;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Mongo.map)
}

// .city.config.v1.MongoPath facilities = 3 [json_name = "facilities"];
inline bool Mongo::_internal_has_facilities() const {
  return this != internal_default_instance() && _impl_.facilities_ != nullptr;
}
inline bool Mongo::has_facilities() const {
  return _internal_has_facilities();
}
inline const ::city::config::v1::MongoPath& Mongo::_internal_facilities() const {
  const ::city::config::v1::MongoPath* p = _impl_.facilities_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::config::v1::MongoPath&>(
      ::city::config::v1::_MongoPath_default_instance_);
}
inline const ::city::config::v1::MongoPath& Mongo::facilities() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Mongo.facilities)
  return _internal_facilities();
}
inline void Mongo::unsafe_arena_set_allocated_facilities(
    ::city::config::v1::MongoPath* facilities) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.facilities_);
  }
  _impl_.facilities_ = facilities;
  if (facilities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Mongo.facilities)
}
inline ::city::config::v1::MongoPath* Mongo::release_facilities() {
  
  ::city::config::v1::MongoPath* temp = _impl_.facilities_;
  _impl_.facilities_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::config::v1::MongoPath* Mongo::unsafe_arena_release_facilities() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Mongo.facilities)
  
  ::city::config::v1::MongoPath* temp = _impl_.facilities_;
  _impl_.facilities_ = nullptr;
  return temp;
}
inline ::city::config::v1::MongoPath* Mongo::_internal_mutable_facilities() {
  
  if (_impl_.facilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::config::v1::MongoPath>(GetArenaForAllocation());
    _impl_.facilities_ = p;
  }
  return _impl_.facilities_;
}
inline ::city::config::v1::MongoPath* Mongo::mutable_facilities() {
  ::city::config::v1::MongoPath* _msg = _internal_mutable_facilities();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Mongo.facilities)
  return _msg;
}
inline void Mongo::set_allocated_facilities(::city::config::v1::MongoPath* facilities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.facilities_);
  }
  if (facilities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(facilities));
    if (message_arena != submessage_arena) {
      facilities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facilities, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.facilities_ = facilities;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Mongo.facilities)
}

// -------------------------------------------------------------------

// ControlStep

// int32 start = 1 [json_name = "start"];
inline void ControlStep::clear_start() {
  _impl_.start_ = 0;
}
inline int32_t ControlStep::_internal_start() const {
  return _impl_.start_;
}
inline int32_t ControlStep::start() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.ControlStep.start)
  return _internal_start();
}
inline void ControlStep::_internal_set_start(int32_t value) {
  
  _impl_.start_ = value;
}
inline void ControlStep::set_start(int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.ControlStep.start)
}

// int32 total = 2 [json_name = "total"];
inline void ControlStep::clear_total() {
  _impl_.total_ = 0;
}
inline int32_t ControlStep::_internal_total() const {
  return _impl_.total_;
}
inline int32_t ControlStep::total() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.ControlStep.total)
  return _internal_total();
}
inline void ControlStep::_internal_set_total(int32_t value) {
  
  _impl_.total_ = value;
}
inline void ControlStep::set_total(int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.ControlStep.total)
}

// -------------------------------------------------------------------

// Control

// .city.elec.input.v1.ControlStep step = 1 [json_name = "step"];
inline bool Control::_internal_has_step() const {
  return this != internal_default_instance() && _impl_.step_ != nullptr;
}
inline bool Control::has_step() const {
  return _internal_has_step();
}
inline void Control::clear_step() {
  if (GetArenaForAllocation() == nullptr && _impl_.step_ != nullptr) {
    delete _impl_.step_;
  }
  _impl_.step_ = nullptr;
}
inline const ::city::elec::input::v1::ControlStep& Control::_internal_step() const {
  const ::city::elec::input::v1::ControlStep* p = _impl_.step_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::ControlStep&>(
      ::city::elec::input::v1::_ControlStep_default_instance_);
}
inline const ::city::elec::input::v1::ControlStep& Control::step() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Control.step)
  return _internal_step();
}
inline void Control::unsafe_arena_set_allocated_step(
    ::city::elec::input::v1::ControlStep* step) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.step_);
  }
  _impl_.step_ = step;
  if (step) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Control.step)
}
inline ::city::elec::input::v1::ControlStep* Control::release_step() {
  
  ::city::elec::input::v1::ControlStep* temp = _impl_.step_;
  _impl_.step_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::elec::input::v1::ControlStep* Control::unsafe_arena_release_step() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Control.step)
  
  ::city::elec::input::v1::ControlStep* temp = _impl_.step_;
  _impl_.step_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::ControlStep* Control::_internal_mutable_step() {
  
  if (_impl_.step_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::ControlStep>(GetArenaForAllocation());
    _impl_.step_ = p;
  }
  return _impl_.step_;
}
inline ::city::elec::input::v1::ControlStep* Control::mutable_step() {
  ::city::elec::input::v1::ControlStep* _msg = _internal_mutable_step();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Control.step)
  return _msg;
}
inline void Control::set_allocated_step(::city::elec::input::v1::ControlStep* step) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.step_;
  }
  if (step) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(step);
    if (message_arena != submessage_arena) {
      step = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, step, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.step_ = step;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Control.step)
}

// -------------------------------------------------------------------

// OutputSwitch

// bool node = 1 [json_name = "node"];
inline void OutputSwitch::clear_node() {
  _impl_.node_ = false;
}
inline bool OutputSwitch::_internal_node() const {
  return _impl_.node_;
}
inline bool OutputSwitch::node() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.OutputSwitch.node)
  return _internal_node();
}
inline void OutputSwitch::_internal_set_node(bool value) {
  
  _impl_.node_ = value;
}
inline void OutputSwitch::set_node(bool value) {
  _internal_set_node(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.OutputSwitch.node)
}

// bool aoi = 2 [json_name = "aoi"];
inline void OutputSwitch::clear_aoi() {
  _impl_.aoi_ = false;
}
inline bool OutputSwitch::_internal_aoi() const {
  return _impl_.aoi_;
}
inline bool OutputSwitch::aoi() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.OutputSwitch.aoi)
  return _internal_aoi();
}
inline void OutputSwitch::_internal_set_aoi(bool value) {
  
  _impl_.aoi_ = value;
}
inline void OutputSwitch::set_aoi(bool value) {
  _internal_set_aoi(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.OutputSwitch.aoi)
}

// bool event = 3 [json_name = "event"];
inline void OutputSwitch::clear_event() {
  _impl_.event_ = false;
}
inline bool OutputSwitch::_internal_event() const {
  return _impl_.event_;
}
inline bool OutputSwitch::event() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.OutputSwitch.event)
  return _internal_event();
}
inline void OutputSwitch::_internal_set_event(bool value) {
  
  _impl_.event_ = value;
}
inline void OutputSwitch::set_event(bool value) {
  _internal_set_event(value);
  // @@protoc_insertion_point(field_set:city.elec.input.v1.OutputSwitch.event)
}

// -------------------------------------------------------------------

// Output

// .city.config.v1.OutputTarget target = 1 [json_name = "target"];
inline bool Output::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool Output::has_target() const {
  return _internal_has_target();
}
inline const ::city::config::v1::OutputTarget& Output::_internal_target() const {
  const ::city::config::v1::OutputTarget* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::config::v1::OutputTarget&>(
      ::city::config::v1::_OutputTarget_default_instance_);
}
inline const ::city::config::v1::OutputTarget& Output::target() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Output.target)
  return _internal_target();
}
inline void Output::unsafe_arena_set_allocated_target(
    ::city::config::v1::OutputTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Output.target)
}
inline ::city::config::v1::OutputTarget* Output::release_target() {
  
  ::city::config::v1::OutputTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::config::v1::OutputTarget* Output::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Output.target)
  
  ::city::config::v1::OutputTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::city::config::v1::OutputTarget* Output::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::config::v1::OutputTarget>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::city::config::v1::OutputTarget* Output::mutable_target() {
  ::city::config::v1::OutputTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Output.target)
  return _msg;
}
inline void Output::set_allocated_target(::city::config::v1::OutputTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target));
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Output.target)
}

// .city.elec.input.v1.OutputSwitch switch = 2 [json_name = "switch"];
inline bool Output::_internal_has_switch_() const {
  return this != internal_default_instance() && _impl_.switch__ != nullptr;
}
inline bool Output::has_switch_() const {
  return _internal_has_switch_();
}
inline void Output::clear_switch_() {
  if (GetArenaForAllocation() == nullptr && _impl_.switch__ != nullptr) {
    delete _impl_.switch__;
  }
  _impl_.switch__ = nullptr;
}
inline const ::city::elec::input::v1::OutputSwitch& Output::_internal_switch_() const {
  const ::city::elec::input::v1::OutputSwitch* p = _impl_.switch__;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::OutputSwitch&>(
      ::city::elec::input::v1::_OutputSwitch_default_instance_);
}
inline const ::city::elec::input::v1::OutputSwitch& Output::switch_() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Output.switch)
  return _internal_switch_();
}
inline void Output::unsafe_arena_set_allocated_switch_(
    ::city::elec::input::v1::OutputSwitch* switch_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.switch__);
  }
  _impl_.switch__ = switch_;
  if (switch_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Output.switch)
}
inline ::city::elec::input::v1::OutputSwitch* Output::release_switch_() {
  
  ::city::elec::input::v1::OutputSwitch* temp = _impl_.switch__;
  _impl_.switch__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::elec::input::v1::OutputSwitch* Output::unsafe_arena_release_switch_() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Output.switch)
  
  ::city::elec::input::v1::OutputSwitch* temp = _impl_.switch__;
  _impl_.switch__ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::OutputSwitch* Output::_internal_mutable_switch_() {
  
  if (_impl_.switch__ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::OutputSwitch>(GetArenaForAllocation());
    _impl_.switch__ = p;
  }
  return _impl_.switch__;
}
inline ::city::elec::input::v1::OutputSwitch* Output::mutable_switch_() {
  ::city::elec::input::v1::OutputSwitch* _msg = _internal_mutable_switch_();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Output.switch)
  return _msg;
}
inline void Output::set_allocated_switch_(::city::elec::input::v1::OutputSwitch* switch_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.switch__;
  }
  if (switch_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(switch_);
    if (message_arena != submessage_arena) {
      switch_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, switch_, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.switch__ = switch_;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Output.switch)
}

// -------------------------------------------------------------------

// Config

// .city.elec.input.v1.Mongo mongo = 1 [json_name = "mongo"];
inline bool Config::_internal_has_mongo() const {
  return this != internal_default_instance() && _impl_.mongo_ != nullptr;
}
inline bool Config::has_mongo() const {
  return _internal_has_mongo();
}
inline void Config::clear_mongo() {
  if (GetArenaForAllocation() == nullptr && _impl_.mongo_ != nullptr) {
    delete _impl_.mongo_;
  }
  _impl_.mongo_ = nullptr;
}
inline const ::city::elec::input::v1::Mongo& Config::_internal_mongo() const {
  const ::city::elec::input::v1::Mongo* p = _impl_.mongo_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::Mongo&>(
      ::city::elec::input::v1::_Mongo_default_instance_);
}
inline const ::city::elec::input::v1::Mongo& Config::mongo() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Config.mongo)
  return _internal_mongo();
}
inline void Config::unsafe_arena_set_allocated_mongo(
    ::city::elec::input::v1::Mongo* mongo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mongo_);
  }
  _impl_.mongo_ = mongo;
  if (mongo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Config.mongo)
}
inline ::city::elec::input::v1::Mongo* Config::release_mongo() {
  
  ::city::elec::input::v1::Mongo* temp = _impl_.mongo_;
  _impl_.mongo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::elec::input::v1::Mongo* Config::unsafe_arena_release_mongo() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Config.mongo)
  
  ::city::elec::input::v1::Mongo* temp = _impl_.mongo_;
  _impl_.mongo_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::Mongo* Config::_internal_mutable_mongo() {
  
  if (_impl_.mongo_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::Mongo>(GetArenaForAllocation());
    _impl_.mongo_ = p;
  }
  return _impl_.mongo_;
}
inline ::city::elec::input::v1::Mongo* Config::mutable_mongo() {
  ::city::elec::input::v1::Mongo* _msg = _internal_mutable_mongo();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Config.mongo)
  return _msg;
}
inline void Config::set_allocated_mongo(::city::elec::input::v1::Mongo* mongo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mongo_;
  }
  if (mongo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mongo);
    if (message_arena != submessage_arena) {
      mongo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mongo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mongo_ = mongo;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Config.mongo)
}

// .city.elec.input.v1.Control control = 2 [json_name = "control"];
inline bool Config::_internal_has_control() const {
  return this != internal_default_instance() && _impl_.control_ != nullptr;
}
inline bool Config::has_control() const {
  return _internal_has_control();
}
inline void Config::clear_control() {
  if (GetArenaForAllocation() == nullptr && _impl_.control_ != nullptr) {
    delete _impl_.control_;
  }
  _impl_.control_ = nullptr;
}
inline const ::city::elec::input::v1::Control& Config::_internal_control() const {
  const ::city::elec::input::v1::Control* p = _impl_.control_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::Control&>(
      ::city::elec::input::v1::_Control_default_instance_);
}
inline const ::city::elec::input::v1::Control& Config::control() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Config.control)
  return _internal_control();
}
inline void Config::unsafe_arena_set_allocated_control(
    ::city::elec::input::v1::Control* control) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_);
  }
  _impl_.control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Config.control)
}
inline ::city::elec::input::v1::Control* Config::release_control() {
  
  ::city::elec::input::v1::Control* temp = _impl_.control_;
  _impl_.control_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::elec::input::v1::Control* Config::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Config.control)
  
  ::city::elec::input::v1::Control* temp = _impl_.control_;
  _impl_.control_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::Control* Config::_internal_mutable_control() {
  
  if (_impl_.control_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::Control>(GetArenaForAllocation());
    _impl_.control_ = p;
  }
  return _impl_.control_;
}
inline ::city::elec::input::v1::Control* Config::mutable_control() {
  ::city::elec::input::v1::Control* _msg = _internal_mutable_control();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Config.control)
  return _msg;
}
inline void Config::set_allocated_control(::city::elec::input::v1::Control* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.control_ = control;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Config.control)
}

// .city.elec.input.v1.Output output = 3 [json_name = "output"];
inline bool Config::_internal_has_output() const {
  return this != internal_default_instance() && _impl_.output_ != nullptr;
}
inline bool Config::has_output() const {
  return _internal_has_output();
}
inline void Config::clear_output() {
  if (GetArenaForAllocation() == nullptr && _impl_.output_ != nullptr) {
    delete _impl_.output_;
  }
  _impl_.output_ = nullptr;
}
inline const ::city::elec::input::v1::Output& Config::_internal_output() const {
  const ::city::elec::input::v1::Output* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::elec::input::v1::Output&>(
      ::city::elec::input::v1::_Output_default_instance_);
}
inline const ::city::elec::input::v1::Output& Config::output() const {
  // @@protoc_insertion_point(field_get:city.elec.input.v1.Config.output)
  return _internal_output();
}
inline void Config::unsafe_arena_set_allocated_output(
    ::city::elec::input::v1::Output* output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = output;
  if (output) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.elec.input.v1.Config.output)
}
inline ::city::elec::input::v1::Output* Config::release_output() {
  
  ::city::elec::input::v1::Output* temp = _impl_.output_;
  _impl_.output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::elec::input::v1::Output* Config::unsafe_arena_release_output() {
  // @@protoc_insertion_point(field_release:city.elec.input.v1.Config.output)
  
  ::city::elec::input::v1::Output* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::city::elec::input::v1::Output* Config::_internal_mutable_output() {
  
  if (_impl_.output_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::elec::input::v1::Output>(GetArenaForAllocation());
    _impl_.output_ = p;
  }
  return _impl_.output_;
}
inline ::city::elec::input::v1::Output* Config::mutable_output() {
  ::city::elec::input::v1::Output* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:city.elec.input.v1.Config.output)
  return _msg;
}
inline void Config::set_allocated_output(::city::elec::input::v1::Output* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output);
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.output_ = output;
  // @@protoc_insertion_point(field_set_allocated:city.elec.input.v1.Config.output)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace input
}  // namespace elec
}  // namespace city

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_city_2felec_2finput_2fv1_2fconfig_2eproto

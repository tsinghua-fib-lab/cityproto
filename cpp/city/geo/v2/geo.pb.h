// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: city/geo/v2/geo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_city_2fgeo_2fv2_2fgeo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_city_2fgeo_2fv2_2fgeo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_city_2fgeo_2fv2_2fgeo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_city_2fgeo_2fv2_2fgeo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_city_2fgeo_2fv2_2fgeo_2eproto;
namespace city {
namespace geo {
namespace v2 {
class AoiPosition;
struct AoiPositionDefaultTypeInternal;
extern AoiPositionDefaultTypeInternal _AoiPosition_default_instance_;
class LanePosition;
struct LanePositionDefaultTypeInternal;
extern LanePositionDefaultTypeInternal _LanePosition_default_instance_;
class LongLatBBox;
struct LongLatBBoxDefaultTypeInternal;
extern LongLatBBoxDefaultTypeInternal _LongLatBBox_default_instance_;
class LongLatPosition;
struct LongLatPositionDefaultTypeInternal;
extern LongLatPositionDefaultTypeInternal _LongLatPosition_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class XYPosition;
struct XYPositionDefaultTypeInternal;
extern XYPositionDefaultTypeInternal _XYPosition_default_instance_;
}  // namespace v2
}  // namespace geo
}  // namespace city
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace city {
namespace geo {
namespace v2 {

// ===================================================================


// -------------------------------------------------------------------

class LongLatPosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.geo.v2.LongLatPosition) */ {
 public:
  inline LongLatPosition() : LongLatPosition(nullptr) {}
  ~LongLatPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LongLatPosition(::google::protobuf::internal::ConstantInitialized);

  LongLatPosition(const LongLatPosition& from);
  LongLatPosition(LongLatPosition&& from) noexcept
    : LongLatPosition() {
    *this = ::std::move(from);
  }

  inline LongLatPosition& operator=(const LongLatPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongLatPosition& operator=(LongLatPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongLatPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongLatPosition* internal_default_instance() {
    return reinterpret_cast<const LongLatPosition*>(
               &_LongLatPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LongLatPosition& a, LongLatPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(LongLatPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongLatPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongLatPosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongLatPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LongLatPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LongLatPosition& from) {
    LongLatPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongLatPosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.geo.v2.LongLatPosition";
  }
  protected:
  explicit LongLatPosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double longitude = 1 [json_name = "longitude"];
  void clear_longitude() ;
  double longitude() const;
  void set_longitude(double value);

  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);

  public:
  // double latitude = 2 [json_name = "latitude"];
  void clear_latitude() ;
  double latitude() const;
  void set_latitude(double value);

  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);

  public:
  // optional double z = 3 [json_name = "z"];
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.geo.v2.LongLatPosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double longitude_;
    double latitude_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fgeo_2fv2_2fgeo_2eproto;
};// -------------------------------------------------------------------

class XYPosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.geo.v2.XYPosition) */ {
 public:
  inline XYPosition() : XYPosition(nullptr) {}
  ~XYPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR XYPosition(::google::protobuf::internal::ConstantInitialized);

  XYPosition(const XYPosition& from);
  XYPosition(XYPosition&& from) noexcept
    : XYPosition() {
    *this = ::std::move(from);
  }

  inline XYPosition& operator=(const XYPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline XYPosition& operator=(XYPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XYPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const XYPosition* internal_default_instance() {
    return reinterpret_cast<const XYPosition*>(
               &_XYPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(XYPosition& a, XYPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(XYPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XYPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XYPosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XYPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XYPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const XYPosition& from) {
    XYPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XYPosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.geo.v2.XYPosition";
  }
  protected:
  explicit XYPosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1 [json_name = "x"];
  void clear_x() ;
  double x() const;
  void set_x(double value);

  private:
  double _internal_x() const;
  void _internal_set_x(double value);

  public:
  // double y = 2 [json_name = "y"];
  void clear_y() ;
  double y() const;
  void set_y(double value);

  private:
  double _internal_y() const;
  void _internal_set_y(double value);

  public:
  // optional double z = 3 [json_name = "z"];
  bool has_z() const;
  void clear_z() ;
  double z() const;
  void set_z(double value);

  private:
  double _internal_z() const;
  void _internal_set_z(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.geo.v2.XYPosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double x_;
    double y_;
    double z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fgeo_2fv2_2fgeo_2eproto;
};// -------------------------------------------------------------------

class LanePosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.geo.v2.LanePosition) */ {
 public:
  inline LanePosition() : LanePosition(nullptr) {}
  ~LanePosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LanePosition(::google::protobuf::internal::ConstantInitialized);

  LanePosition(const LanePosition& from);
  LanePosition(LanePosition&& from) noexcept
    : LanePosition() {
    *this = ::std::move(from);
  }

  inline LanePosition& operator=(const LanePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline LanePosition& operator=(LanePosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LanePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const LanePosition* internal_default_instance() {
    return reinterpret_cast<const LanePosition*>(
               &_LanePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LanePosition& a, LanePosition& b) {
    a.Swap(&b);
  }
  inline void Swap(LanePosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LanePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LanePosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LanePosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LanePosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LanePosition& from) {
    LanePosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LanePosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.geo.v2.LanePosition";
  }
  protected:
  explicit LanePosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 2,
    kLaneIdFieldNumber = 1,
  };
  // double s = 2 [json_name = "s"];
  void clear_s() ;
  double s() const;
  void set_s(double value);

  private:
  double _internal_s() const;
  void _internal_set_s(double value);

  public:
  // int32 lane_id = 1 [json_name = "laneId"];
  void clear_lane_id() ;
  ::int32_t lane_id() const;
  void set_lane_id(::int32_t value);

  private:
  ::int32_t _internal_lane_id() const;
  void _internal_set_lane_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:city.geo.v2.LanePosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double s_;
    ::int32_t lane_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fgeo_2fv2_2fgeo_2eproto;
};// -------------------------------------------------------------------

class AoiPosition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.geo.v2.AoiPosition) */ {
 public:
  inline AoiPosition() : AoiPosition(nullptr) {}
  ~AoiPosition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AoiPosition(::google::protobuf::internal::ConstantInitialized);

  AoiPosition(const AoiPosition& from);
  AoiPosition(AoiPosition&& from) noexcept
    : AoiPosition() {
    *this = ::std::move(from);
  }

  inline AoiPosition& operator=(const AoiPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AoiPosition& operator=(AoiPosition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AoiPosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AoiPosition* internal_default_instance() {
    return reinterpret_cast<const AoiPosition*>(
               &_AoiPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AoiPosition& a, AoiPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(AoiPosition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AoiPosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AoiPosition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AoiPosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AoiPosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AoiPosition& from) {
    AoiPosition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AoiPosition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.geo.v2.AoiPosition";
  }
  protected:
  explicit AoiPosition(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAoiIdFieldNumber = 1,
    kPoiIdFieldNumber = 2,
  };
  // int32 aoi_id = 1 [json_name = "aoiId"];
  void clear_aoi_id() ;
  ::int32_t aoi_id() const;
  void set_aoi_id(::int32_t value);

  private:
  ::int32_t _internal_aoi_id() const;
  void _internal_set_aoi_id(::int32_t value);

  public:
  // optional int32 poi_id = 2 [json_name = "poiId"];
  bool has_poi_id() const;
  void clear_poi_id() ;
  ::int32_t poi_id() const;
  void set_poi_id(::int32_t value);

  private:
  ::int32_t _internal_poi_id() const;
  void _internal_set_poi_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:city.geo.v2.AoiPosition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t aoi_id_;
    ::int32_t poi_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fgeo_2fv2_2fgeo_2eproto;
};// -------------------------------------------------------------------

class Position final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.geo.v2.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Position(::google::protobuf::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.geo.v2.Position";
  }
  protected:
  explicit Position(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanePositionFieldNumber = 1,
    kAoiPositionFieldNumber = 2,
    kLonglatPositionFieldNumber = 3,
    kXyPositionFieldNumber = 4,
  };
  // optional .city.geo.v2.LanePosition lane_position = 1 [json_name = "lanePosition"];
  bool has_lane_position() const;
  void clear_lane_position() ;
  const ::city::geo::v2::LanePosition& lane_position() const;
  PROTOBUF_NODISCARD ::city::geo::v2::LanePosition* release_lane_position();
  ::city::geo::v2::LanePosition* mutable_lane_position();
  void set_allocated_lane_position(::city::geo::v2::LanePosition* value);
  void unsafe_arena_set_allocated_lane_position(::city::geo::v2::LanePosition* value);
  ::city::geo::v2::LanePosition* unsafe_arena_release_lane_position();

  private:
  const ::city::geo::v2::LanePosition& _internal_lane_position() const;
  ::city::geo::v2::LanePosition* _internal_mutable_lane_position();

  public:
  // optional .city.geo.v2.AoiPosition aoi_position = 2 [json_name = "aoiPosition"];
  bool has_aoi_position() const;
  void clear_aoi_position() ;
  const ::city::geo::v2::AoiPosition& aoi_position() const;
  PROTOBUF_NODISCARD ::city::geo::v2::AoiPosition* release_aoi_position();
  ::city::geo::v2::AoiPosition* mutable_aoi_position();
  void set_allocated_aoi_position(::city::geo::v2::AoiPosition* value);
  void unsafe_arena_set_allocated_aoi_position(::city::geo::v2::AoiPosition* value);
  ::city::geo::v2::AoiPosition* unsafe_arena_release_aoi_position();

  private:
  const ::city::geo::v2::AoiPosition& _internal_aoi_position() const;
  ::city::geo::v2::AoiPosition* _internal_mutable_aoi_position();

  public:
  // optional .city.geo.v2.LongLatPosition longlat_position = 3 [json_name = "longlatPosition"];
  bool has_longlat_position() const;
  void clear_longlat_position() ;
  const ::city::geo::v2::LongLatPosition& longlat_position() const;
  PROTOBUF_NODISCARD ::city::geo::v2::LongLatPosition* release_longlat_position();
  ::city::geo::v2::LongLatPosition* mutable_longlat_position();
  void set_allocated_longlat_position(::city::geo::v2::LongLatPosition* value);
  void unsafe_arena_set_allocated_longlat_position(::city::geo::v2::LongLatPosition* value);
  ::city::geo::v2::LongLatPosition* unsafe_arena_release_longlat_position();

  private:
  const ::city::geo::v2::LongLatPosition& _internal_longlat_position() const;
  ::city::geo::v2::LongLatPosition* _internal_mutable_longlat_position();

  public:
  // optional .city.geo.v2.XYPosition xy_position = 4 [json_name = "xyPosition"];
  bool has_xy_position() const;
  void clear_xy_position() ;
  const ::city::geo::v2::XYPosition& xy_position() const;
  PROTOBUF_NODISCARD ::city::geo::v2::XYPosition* release_xy_position();
  ::city::geo::v2::XYPosition* mutable_xy_position();
  void set_allocated_xy_position(::city::geo::v2::XYPosition* value);
  void unsafe_arena_set_allocated_xy_position(::city::geo::v2::XYPosition* value);
  ::city::geo::v2::XYPosition* unsafe_arena_release_xy_position();

  private:
  const ::city::geo::v2::XYPosition& _internal_xy_position() const;
  ::city::geo::v2::XYPosition* _internal_mutable_xy_position();

  public:
  // @@protoc_insertion_point(class_scope:city.geo.v2.Position)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 4, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::geo::v2::LanePosition* lane_position_;
    ::city::geo::v2::AoiPosition* aoi_position_;
    ::city::geo::v2::LongLatPosition* longlat_position_;
    ::city::geo::v2::XYPosition* xy_position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fgeo_2fv2_2fgeo_2eproto;
};// -------------------------------------------------------------------

class LongLatBBox final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.geo.v2.LongLatBBox) */ {
 public:
  inline LongLatBBox() : LongLatBBox(nullptr) {}
  ~LongLatBBox() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LongLatBBox(::google::protobuf::internal::ConstantInitialized);

  LongLatBBox(const LongLatBBox& from);
  LongLatBBox(LongLatBBox&& from) noexcept
    : LongLatBBox() {
    *this = ::std::move(from);
  }

  inline LongLatBBox& operator=(const LongLatBBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongLatBBox& operator=(LongLatBBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongLatBBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongLatBBox* internal_default_instance() {
    return reinterpret_cast<const LongLatBBox*>(
               &_LongLatBBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LongLatBBox& a, LongLatBBox& b) {
    a.Swap(&b);
  }
  inline void Swap(LongLatBBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongLatBBox* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongLatBBox* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongLatBBox>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LongLatBBox& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LongLatBBox& from) {
    LongLatBBox::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongLatBBox* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.geo.v2.LongLatBBox";
  }
  protected:
  explicit LongLatBBox(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinLongitudeFieldNumber = 1,
    kMinLatitudeFieldNumber = 2,
    kMaxLongitudeFieldNumber = 3,
    kMaxLatitudeFieldNumber = 4,
  };
  // double min_longitude = 1 [json_name = "minLongitude"];
  void clear_min_longitude() ;
  double min_longitude() const;
  void set_min_longitude(double value);

  private:
  double _internal_min_longitude() const;
  void _internal_set_min_longitude(double value);

  public:
  // double min_latitude = 2 [json_name = "minLatitude"];
  void clear_min_latitude() ;
  double min_latitude() const;
  void set_min_latitude(double value);

  private:
  double _internal_min_latitude() const;
  void _internal_set_min_latitude(double value);

  public:
  // double max_longitude = 3 [json_name = "maxLongitude"];
  void clear_max_longitude() ;
  double max_longitude() const;
  void set_max_longitude(double value);

  private:
  double _internal_max_longitude() const;
  void _internal_set_max_longitude(double value);

  public:
  // double max_latitude = 4 [json_name = "maxLatitude"];
  void clear_max_latitude() ;
  double max_latitude() const;
  void set_max_latitude(double value);

  private:
  double _internal_max_latitude() const;
  void _internal_set_max_latitude(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.geo.v2.LongLatBBox)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double min_longitude_;
    double min_latitude_;
    double max_longitude_;
    double max_latitude_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fgeo_2fv2_2fgeo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// LongLatPosition

// double longitude = 1 [json_name = "longitude"];
inline void LongLatPosition::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline double LongLatPosition::longitude() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatPosition.longitude)
  return _internal_longitude();
}
inline void LongLatPosition::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatPosition.longitude)
}
inline double LongLatPosition::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.longitude_;
}
inline void LongLatPosition::_internal_set_longitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.longitude_ = value;
}

// double latitude = 2 [json_name = "latitude"];
inline void LongLatPosition::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline double LongLatPosition::latitude() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatPosition.latitude)
  return _internal_latitude();
}
inline void LongLatPosition::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatPosition.latitude)
}
inline double LongLatPosition::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.latitude_;
}
inline void LongLatPosition::_internal_set_latitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.latitude_ = value;
}

// optional double z = 3 [json_name = "z"];
inline bool LongLatPosition::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LongLatPosition::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double LongLatPosition::z() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatPosition.z)
  return _internal_z();
}
inline void LongLatPosition::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatPosition.z)
}
inline double LongLatPosition::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void LongLatPosition::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// XYPosition

// double x = 1 [json_name = "x"];
inline void XYPosition::clear_x() {
  _impl_.x_ = 0;
}
inline double XYPosition::x() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.XYPosition.x)
  return _internal_x();
}
inline void XYPosition::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.XYPosition.x)
}
inline double XYPosition::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void XYPosition::_internal_set_x(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// double y = 2 [json_name = "y"];
inline void XYPosition::clear_y() {
  _impl_.y_ = 0;
}
inline double XYPosition::y() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.XYPosition.y)
  return _internal_y();
}
inline void XYPosition::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.XYPosition.y)
}
inline double XYPosition::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void XYPosition::_internal_set_y(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// optional double z = 3 [json_name = "z"];
inline bool XYPosition::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void XYPosition::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double XYPosition::z() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.XYPosition.z)
  return _internal_z();
}
inline void XYPosition::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.XYPosition.z)
}
inline double XYPosition::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void XYPosition::_internal_set_z(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// LanePosition

// int32 lane_id = 1 [json_name = "laneId"];
inline void LanePosition::clear_lane_id() {
  _impl_.lane_id_ = 0;
}
inline ::int32_t LanePosition::lane_id() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LanePosition.lane_id)
  return _internal_lane_id();
}
inline void LanePosition::set_lane_id(::int32_t value) {
  _internal_set_lane_id(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LanePosition.lane_id)
}
inline ::int32_t LanePosition::_internal_lane_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_id_;
}
inline void LanePosition::_internal_set_lane_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lane_id_ = value;
}

// double s = 2 [json_name = "s"];
inline void LanePosition::clear_s() {
  _impl_.s_ = 0;
}
inline double LanePosition::s() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LanePosition.s)
  return _internal_s();
}
inline void LanePosition::set_s(double value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LanePosition.s)
}
inline double LanePosition::_internal_s() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s_;
}
inline void LanePosition::_internal_set_s(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.s_ = value;
}

// -------------------------------------------------------------------

// AoiPosition

// int32 aoi_id = 1 [json_name = "aoiId"];
inline void AoiPosition::clear_aoi_id() {
  _impl_.aoi_id_ = 0;
}
inline ::int32_t AoiPosition::aoi_id() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.AoiPosition.aoi_id)
  return _internal_aoi_id();
}
inline void AoiPosition::set_aoi_id(::int32_t value) {
  _internal_set_aoi_id(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.AoiPosition.aoi_id)
}
inline ::int32_t AoiPosition::_internal_aoi_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aoi_id_;
}
inline void AoiPosition::_internal_set_aoi_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aoi_id_ = value;
}

// optional int32 poi_id = 2 [json_name = "poiId"];
inline bool AoiPosition::has_poi_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AoiPosition::clear_poi_id() {
  _impl_.poi_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AoiPosition::poi_id() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.AoiPosition.poi_id)
  return _internal_poi_id();
}
inline void AoiPosition::set_poi_id(::int32_t value) {
  _internal_set_poi_id(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.AoiPosition.poi_id)
}
inline ::int32_t AoiPosition::_internal_poi_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.poi_id_;
}
inline void AoiPosition::_internal_set_poi_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.poi_id_ = value;
}

// -------------------------------------------------------------------

// Position

// optional .city.geo.v2.LanePosition lane_position = 1 [json_name = "lanePosition"];
inline bool Position::has_lane_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_position_ != nullptr);
  return value;
}
inline void Position::clear_lane_position() {
  if (_impl_.lane_position_ != nullptr) _impl_.lane_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::city::geo::v2::LanePosition& Position::_internal_lane_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::geo::v2::LanePosition* p = _impl_.lane_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::geo::v2::LanePosition&>(::city::geo::v2::_LanePosition_default_instance_);
}
inline const ::city::geo::v2::LanePosition& Position::lane_position() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.Position.lane_position)
  return _internal_lane_position();
}
inline void Position::unsafe_arena_set_allocated_lane_position(::city::geo::v2::LanePosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lane_position_);
  }
  _impl_.lane_position_ = reinterpret_cast<::city::geo::v2::LanePosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.geo.v2.Position.lane_position)
}
inline ::city::geo::v2::LanePosition* Position::release_lane_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::geo::v2::LanePosition* released = _impl_.lane_position_;
  _impl_.lane_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::geo::v2::LanePosition* Position::unsafe_arena_release_lane_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.geo.v2.Position.lane_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::geo::v2::LanePosition* temp = _impl_.lane_position_;
  _impl_.lane_position_ = nullptr;
  return temp;
}
inline ::city::geo::v2::LanePosition* Position::_internal_mutable_lane_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lane_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::geo::v2::LanePosition>(GetArenaForAllocation());
    _impl_.lane_position_ = reinterpret_cast<::city::geo::v2::LanePosition*>(p);
  }
  return _impl_.lane_position_;
}
inline ::city::geo::v2::LanePosition* Position::mutable_lane_position() {
  ::city::geo::v2::LanePosition* _msg = _internal_mutable_lane_position();
  // @@protoc_insertion_point(field_mutable:city.geo.v2.Position.lane_position)
  return _msg;
}
inline void Position::set_allocated_lane_position(::city::geo::v2::LanePosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::geo::v2::LanePosition*>(_impl_.lane_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::geo::v2::LanePosition*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lane_position_ = reinterpret_cast<::city::geo::v2::LanePosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.geo.v2.Position.lane_position)
}

// optional .city.geo.v2.AoiPosition aoi_position = 2 [json_name = "aoiPosition"];
inline bool Position::has_aoi_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.aoi_position_ != nullptr);
  return value;
}
inline void Position::clear_aoi_position() {
  if (_impl_.aoi_position_ != nullptr) _impl_.aoi_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::city::geo::v2::AoiPosition& Position::_internal_aoi_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::geo::v2::AoiPosition* p = _impl_.aoi_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::geo::v2::AoiPosition&>(::city::geo::v2::_AoiPosition_default_instance_);
}
inline const ::city::geo::v2::AoiPosition& Position::aoi_position() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.Position.aoi_position)
  return _internal_aoi_position();
}
inline void Position::unsafe_arena_set_allocated_aoi_position(::city::geo::v2::AoiPosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.aoi_position_);
  }
  _impl_.aoi_position_ = reinterpret_cast<::city::geo::v2::AoiPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.geo.v2.Position.aoi_position)
}
inline ::city::geo::v2::AoiPosition* Position::release_aoi_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::geo::v2::AoiPosition* released = _impl_.aoi_position_;
  _impl_.aoi_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::geo::v2::AoiPosition* Position::unsafe_arena_release_aoi_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.geo.v2.Position.aoi_position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::geo::v2::AoiPosition* temp = _impl_.aoi_position_;
  _impl_.aoi_position_ = nullptr;
  return temp;
}
inline ::city::geo::v2::AoiPosition* Position::_internal_mutable_aoi_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.aoi_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::geo::v2::AoiPosition>(GetArenaForAllocation());
    _impl_.aoi_position_ = reinterpret_cast<::city::geo::v2::AoiPosition*>(p);
  }
  return _impl_.aoi_position_;
}
inline ::city::geo::v2::AoiPosition* Position::mutable_aoi_position() {
  ::city::geo::v2::AoiPosition* _msg = _internal_mutable_aoi_position();
  // @@protoc_insertion_point(field_mutable:city.geo.v2.Position.aoi_position)
  return _msg;
}
inline void Position::set_allocated_aoi_position(::city::geo::v2::AoiPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::geo::v2::AoiPosition*>(_impl_.aoi_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::geo::v2::AoiPosition*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.aoi_position_ = reinterpret_cast<::city::geo::v2::AoiPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.geo.v2.Position.aoi_position)
}

// optional .city.geo.v2.LongLatPosition longlat_position = 3 [json_name = "longlatPosition"];
inline bool Position::has_longlat_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.longlat_position_ != nullptr);
  return value;
}
inline void Position::clear_longlat_position() {
  if (_impl_.longlat_position_ != nullptr) _impl_.longlat_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::city::geo::v2::LongLatPosition& Position::_internal_longlat_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::geo::v2::LongLatPosition* p = _impl_.longlat_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::geo::v2::LongLatPosition&>(::city::geo::v2::_LongLatPosition_default_instance_);
}
inline const ::city::geo::v2::LongLatPosition& Position::longlat_position() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.Position.longlat_position)
  return _internal_longlat_position();
}
inline void Position::unsafe_arena_set_allocated_longlat_position(::city::geo::v2::LongLatPosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longlat_position_);
  }
  _impl_.longlat_position_ = reinterpret_cast<::city::geo::v2::LongLatPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.geo.v2.Position.longlat_position)
}
inline ::city::geo::v2::LongLatPosition* Position::release_longlat_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::geo::v2::LongLatPosition* released = _impl_.longlat_position_;
  _impl_.longlat_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::geo::v2::LongLatPosition* Position::unsafe_arena_release_longlat_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.geo.v2.Position.longlat_position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::geo::v2::LongLatPosition* temp = _impl_.longlat_position_;
  _impl_.longlat_position_ = nullptr;
  return temp;
}
inline ::city::geo::v2::LongLatPosition* Position::_internal_mutable_longlat_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.longlat_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::geo::v2::LongLatPosition>(GetArenaForAllocation());
    _impl_.longlat_position_ = reinterpret_cast<::city::geo::v2::LongLatPosition*>(p);
  }
  return _impl_.longlat_position_;
}
inline ::city::geo::v2::LongLatPosition* Position::mutable_longlat_position() {
  ::city::geo::v2::LongLatPosition* _msg = _internal_mutable_longlat_position();
  // @@protoc_insertion_point(field_mutable:city.geo.v2.Position.longlat_position)
  return _msg;
}
inline void Position::set_allocated_longlat_position(::city::geo::v2::LongLatPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::geo::v2::LongLatPosition*>(_impl_.longlat_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::geo::v2::LongLatPosition*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.longlat_position_ = reinterpret_cast<::city::geo::v2::LongLatPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.geo.v2.Position.longlat_position)
}

// optional .city.geo.v2.XYPosition xy_position = 4 [json_name = "xyPosition"];
inline bool Position::has_xy_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.xy_position_ != nullptr);
  return value;
}
inline void Position::clear_xy_position() {
  if (_impl_.xy_position_ != nullptr) _impl_.xy_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::city::geo::v2::XYPosition& Position::_internal_xy_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::geo::v2::XYPosition* p = _impl_.xy_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::geo::v2::XYPosition&>(::city::geo::v2::_XYPosition_default_instance_);
}
inline const ::city::geo::v2::XYPosition& Position::xy_position() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.Position.xy_position)
  return _internal_xy_position();
}
inline void Position::unsafe_arena_set_allocated_xy_position(::city::geo::v2::XYPosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.xy_position_);
  }
  _impl_.xy_position_ = reinterpret_cast<::city::geo::v2::XYPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.geo.v2.Position.xy_position)
}
inline ::city::geo::v2::XYPosition* Position::release_xy_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::city::geo::v2::XYPosition* released = _impl_.xy_position_;
  _impl_.xy_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::geo::v2::XYPosition* Position::unsafe_arena_release_xy_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.geo.v2.Position.xy_position)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::city::geo::v2::XYPosition* temp = _impl_.xy_position_;
  _impl_.xy_position_ = nullptr;
  return temp;
}
inline ::city::geo::v2::XYPosition* Position::_internal_mutable_xy_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.xy_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::geo::v2::XYPosition>(GetArenaForAllocation());
    _impl_.xy_position_ = reinterpret_cast<::city::geo::v2::XYPosition*>(p);
  }
  return _impl_.xy_position_;
}
inline ::city::geo::v2::XYPosition* Position::mutable_xy_position() {
  ::city::geo::v2::XYPosition* _msg = _internal_mutable_xy_position();
  // @@protoc_insertion_point(field_mutable:city.geo.v2.Position.xy_position)
  return _msg;
}
inline void Position::set_allocated_xy_position(::city::geo::v2::XYPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::geo::v2::XYPosition*>(_impl_.xy_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::geo::v2::XYPosition*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.xy_position_ = reinterpret_cast<::city::geo::v2::XYPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.geo.v2.Position.xy_position)
}

// -------------------------------------------------------------------

// LongLatBBox

// double min_longitude = 1 [json_name = "minLongitude"];
inline void LongLatBBox::clear_min_longitude() {
  _impl_.min_longitude_ = 0;
}
inline double LongLatBBox::min_longitude() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatBBox.min_longitude)
  return _internal_min_longitude();
}
inline void LongLatBBox::set_min_longitude(double value) {
  _internal_set_min_longitude(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatBBox.min_longitude)
}
inline double LongLatBBox::_internal_min_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_longitude_;
}
inline void LongLatBBox::_internal_set_min_longitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_longitude_ = value;
}

// double min_latitude = 2 [json_name = "minLatitude"];
inline void LongLatBBox::clear_min_latitude() {
  _impl_.min_latitude_ = 0;
}
inline double LongLatBBox::min_latitude() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatBBox.min_latitude)
  return _internal_min_latitude();
}
inline void LongLatBBox::set_min_latitude(double value) {
  _internal_set_min_latitude(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatBBox.min_latitude)
}
inline double LongLatBBox::_internal_min_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_latitude_;
}
inline void LongLatBBox::_internal_set_min_latitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.min_latitude_ = value;
}

// double max_longitude = 3 [json_name = "maxLongitude"];
inline void LongLatBBox::clear_max_longitude() {
  _impl_.max_longitude_ = 0;
}
inline double LongLatBBox::max_longitude() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatBBox.max_longitude)
  return _internal_max_longitude();
}
inline void LongLatBBox::set_max_longitude(double value) {
  _internal_set_max_longitude(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatBBox.max_longitude)
}
inline double LongLatBBox::_internal_max_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_longitude_;
}
inline void LongLatBBox::_internal_set_max_longitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_longitude_ = value;
}

// double max_latitude = 4 [json_name = "maxLatitude"];
inline void LongLatBBox::clear_max_latitude() {
  _impl_.max_latitude_ = 0;
}
inline double LongLatBBox::max_latitude() const {
  // @@protoc_insertion_point(field_get:city.geo.v2.LongLatBBox.max_latitude)
  return _internal_max_latitude();
}
inline void LongLatBBox::set_max_latitude(double value) {
  _internal_set_max_latitude(value);
  // @@protoc_insertion_point(field_set:city.geo.v2.LongLatBBox.max_latitude)
}
inline double LongLatBBox::_internal_max_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_latitude_;
}
inline void LongLatBBox::_internal_set_max_latitude(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_latitude_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v2
}  // namespace geo
}  // namespace city


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_city_2fgeo_2fv2_2fgeo_2eproto_2epb_2eh

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: city/water/output/v1/output.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_city_2fwater_2foutput_2fv1_2foutput_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_city_2fwater_2foutput_2fv1_2foutput_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "city/geo/v2/geo.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_city_2fwater_2foutput_2fv1_2foutput_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_city_2fwater_2foutput_2fv1_2foutput_2eproto;
namespace city {
namespace water {
namespace output {
namespace v1 {
class Aoi;
struct AoiDefaultTypeInternal;
extern AoiDefaultTypeInternal _Aoi_default_instance_;
class DetailedRoad;
struct DetailedRoadDefaultTypeInternal;
extern DetailedRoadDefaultTypeInternal _DetailedRoad_default_instance_;
class DrainageBasicInfo;
struct DrainageBasicInfoDefaultTypeInternal;
extern DrainageBasicInfoDefaultTypeInternal _DrainageBasicInfo_default_instance_;
class DrainageMetrics;
struct DrainageMetricsDefaultTypeInternal;
extern DrainageMetricsDefaultTypeInternal _DrainageMetrics_default_instance_;
class FailureStatistics;
struct FailureStatisticsDefaultTypeInternal;
extern FailureStatisticsDefaultTypeInternal _FailureStatistics_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Road;
struct RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadFlood;
struct RoadFloodDefaultTypeInternal;
extern RoadFloodDefaultTypeInternal _RoadFlood_default_instance_;
class SupplyBasicInfo;
struct SupplyBasicInfoDefaultTypeInternal;
extern SupplyBasicInfoDefaultTypeInternal _SupplyBasicInfo_default_instance_;
class SupplyDemandStatistics;
struct SupplyDemandStatisticsDefaultTypeInternal;
extern SupplyDemandStatisticsDefaultTypeInternal _SupplyDemandStatistics_default_instance_;
class SupplyMetrics;
struct SupplyMetricsDefaultTypeInternal;
extern SupplyMetricsDefaultTypeInternal _SupplyMetrics_default_instance_;
}  // namespace v1
}  // namespace output
}  // namespace water
}  // namespace city
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace city {
namespace water {
namespace output {
namespace v1 {
enum LinkType : int {
  LINK_TYPE_UNSPECIFIED = 0,
  LINK_TYPE_PIPE = 1,
  LINK_TYPE_PUMP = 2,
  LinkType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LinkType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LinkType_IsValid(int value);
constexpr LinkType LinkType_MIN = static_cast<LinkType>(0);
constexpr LinkType LinkType_MAX = static_cast<LinkType>(2);
constexpr int LinkType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
LinkType_descriptor();
template <typename T>
const std::string& LinkType_Name(T value) {
  static_assert(std::is_same<T, LinkType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LinkType_Name().");
  return LinkType_Name(static_cast<LinkType>(value));
}
template <>
inline const std::string& LinkType_Name(LinkType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LinkType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool LinkType_Parse(absl::string_view name, LinkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinkType>(
      LinkType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Road final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Road) */ {
 public:
  inline Road() : Road(nullptr) {}
  ~Road() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Road(::google::protobuf::internal::ConstantInitialized);

  Road(const Road& from);
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  inline Road& operator=(Road&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Road& default_instance() {
    return *internal_default_instance();
  }
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }
  inline void Swap(Road* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Road* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Road* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Road& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Road& from) {
    Road::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Road* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.Road";
  }
  protected:
  explicit Road(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepthFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // double depth = 2 [json_name = "depth"];
  void clear_depth() ;
  double depth() const;
  void set_depth(double value);

  private:
  double _internal_depth() const;
  void _internal_set_depth(double value);

  public:
  // int32 id = 1 [json_name = "id"];
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.Road)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double depth_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class RoadFlood final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.RoadFlood) */ {
 public:
  inline RoadFlood() : RoadFlood(nullptr) {}
  ~RoadFlood() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadFlood(::google::protobuf::internal::ConstantInitialized);

  RoadFlood(const RoadFlood& from);
  RoadFlood(RoadFlood&& from) noexcept
    : RoadFlood() {
    *this = ::std::move(from);
  }

  inline RoadFlood& operator=(const RoadFlood& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadFlood& operator=(RoadFlood&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadFlood& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadFlood* internal_default_instance() {
    return reinterpret_cast<const RoadFlood*>(
               &_RoadFlood_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoadFlood& a, RoadFlood& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadFlood* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadFlood* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadFlood* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadFlood>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadFlood& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadFlood& from) {
    RoadFlood::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadFlood* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.RoadFlood";
  }
  protected:
  explicit RoadFlood(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kDepthFieldNumber = 2,
  };
  // .city.geo.v2.LongLatPosition position = 1 [json_name = "position"];
  bool has_position() const;
  void clear_position() ;
  const ::city::geo::v2::LongLatPosition& position() const;
  PROTOBUF_NODISCARD ::city::geo::v2::LongLatPosition* release_position();
  ::city::geo::v2::LongLatPosition* mutable_position();
  void set_allocated_position(::city::geo::v2::LongLatPosition* value);
  void unsafe_arena_set_allocated_position(::city::geo::v2::LongLatPosition* value);
  ::city::geo::v2::LongLatPosition* unsafe_arena_release_position();

  private:
  const ::city::geo::v2::LongLatPosition& _internal_position() const;
  ::city::geo::v2::LongLatPosition* _internal_mutable_position();

  public:
  // double depth = 2 [json_name = "depth"];
  void clear_depth() ;
  double depth() const;
  void set_depth(double value);

  private:
  double _internal_depth() const;
  void _internal_set_depth(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.RoadFlood)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::geo::v2::LongLatPosition* position_;
    double depth_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class DetailedRoad final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.DetailedRoad) */ {
 public:
  inline DetailedRoad() : DetailedRoad(nullptr) {}
  ~DetailedRoad() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DetailedRoad(::google::protobuf::internal::ConstantInitialized);

  DetailedRoad(const DetailedRoad& from);
  DetailedRoad(DetailedRoad&& from) noexcept
    : DetailedRoad() {
    *this = ::std::move(from);
  }

  inline DetailedRoad& operator=(const DetailedRoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailedRoad& operator=(DetailedRoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetailedRoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailedRoad* internal_default_instance() {
    return reinterpret_cast<const DetailedRoad*>(
               &_DetailedRoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DetailedRoad& a, DetailedRoad& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailedRoad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailedRoad* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailedRoad* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailedRoad>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DetailedRoad& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DetailedRoad& from) {
    DetailedRoad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailedRoad* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.DetailedRoad";
  }
  protected:
  explicit DetailedRoad(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepthsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .city.water.output.v1.RoadFlood depths = 2 [json_name = "depths"];
  int depths_size() const;
  private:
  int _internal_depths_size() const;

  public:
  void clear_depths() ;
  ::city::water::output::v1::RoadFlood* mutable_depths(int index);
  ::google::protobuf::RepeatedPtrField< ::city::water::output::v1::RoadFlood >*
      mutable_depths();
  private:
  const ::google::protobuf::RepeatedPtrField<::city::water::output::v1::RoadFlood>& _internal_depths() const;
  ::google::protobuf::RepeatedPtrField<::city::water::output::v1::RoadFlood>* _internal_mutable_depths();
  public:
  const ::city::water::output::v1::RoadFlood& depths(int index) const;
  ::city::water::output::v1::RoadFlood* add_depths();
  const ::google::protobuf::RepeatedPtrField< ::city::water::output::v1::RoadFlood >&
      depths() const;
  // int32 id = 1 [json_name = "id"];
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.DetailedRoad)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::city::water::output::v1::RoadFlood > depths_;
    ::int32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class Node final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node(::google::protobuf::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.Node";
  }
  protected:
  explicit Node(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // double head = 2 [json_name = "head"];
  void clear_head() ;
  double head() const;
  void set_head(double value);

  private:
  double _internal_head() const;
  void _internal_set_head(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.Node)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    double head_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class Link final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Link(::google::protobuf::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.Link";
  }
  protected:
  explicit Link(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kFlowFieldNumber = 3,
    kTypeFieldNumber = 2,
    kOkFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // double flow = 3 [json_name = "flow"];
  void clear_flow() ;
  double flow() const;
  void set_flow(double value);

  private:
  double _internal_flow() const;
  void _internal_set_flow(double value);

  public:
  // .city.water.output.v1.LinkType type = 2 [json_name = "type"];
  void clear_type() ;
  ::city::water::output::v1::LinkType type() const;
  void set_type(::city::water::output::v1::LinkType value);

  private:
  ::city::water::output::v1::LinkType _internal_type() const;
  void _internal_set_type(::city::water::output::v1::LinkType value);

  public:
  // bool ok = 4 [json_name = "ok"];
  void clear_ok() ;
  bool ok() const;
  void set_ok(bool value);

  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.Link)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    double flow_;
    int type_;
    bool ok_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class Aoi final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Aoi) */ {
 public:
  inline Aoi() : Aoi(nullptr) {}
  ~Aoi() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aoi(::google::protobuf::internal::ConstantInitialized);

  Aoi(const Aoi& from);
  Aoi(Aoi&& from) noexcept
    : Aoi() {
    *this = ::std::move(from);
  }

  inline Aoi& operator=(const Aoi& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aoi& operator=(Aoi&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aoi& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aoi* internal_default_instance() {
    return reinterpret_cast<const Aoi*>(
               &_Aoi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Aoi& a, Aoi& b) {
    a.Swap(&b);
  }
  inline void Swap(Aoi* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aoi* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aoi* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aoi>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aoi& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aoi& from) {
    Aoi::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aoi* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.Aoi";
  }
  protected:
  explicit Aoi(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUnsatisfiedNumFieldNumber = 2,
    kUnsatisfiedRatioFieldNumber = 3,
    kDemandFieldNumber = 4,
    kSupplyFieldNumber = 5,
  };
  // int32 id = 1 [json_name = "id"];
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // int32 unsatisfied_num = 2 [json_name = "unsatisfiedNum"];
  void clear_unsatisfied_num() ;
  ::int32_t unsatisfied_num() const;
  void set_unsatisfied_num(::int32_t value);

  private:
  ::int32_t _internal_unsatisfied_num() const;
  void _internal_set_unsatisfied_num(::int32_t value);

  public:
  // double unsatisfied_ratio = 3 [json_name = "unsatisfiedRatio"];
  void clear_unsatisfied_ratio() ;
  double unsatisfied_ratio() const;
  void set_unsatisfied_ratio(double value);

  private:
  double _internal_unsatisfied_ratio() const;
  void _internal_set_unsatisfied_ratio(double value);

  public:
  // double demand = 4 [json_name = "demand"];
  void clear_demand() ;
  double demand() const;
  void set_demand(double value);

  private:
  double _internal_demand() const;
  void _internal_set_demand(double value);

  public:
  // double supply = 5 [json_name = "supply"];
  void clear_supply() ;
  double supply() const;
  void set_supply(double value);

  private:
  double _internal_supply() const;
  void _internal_set_supply(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.Aoi)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t id_;
    ::int32_t unsatisfied_num_;
    double unsatisfied_ratio_;
    double demand_;
    double supply_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class DrainageBasicInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.DrainageBasicInfo) */ {
 public:
  inline DrainageBasicInfo() : DrainageBasicInfo(nullptr) {}
  ~DrainageBasicInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DrainageBasicInfo(::google::protobuf::internal::ConstantInitialized);

  DrainageBasicInfo(const DrainageBasicInfo& from);
  DrainageBasicInfo(DrainageBasicInfo&& from) noexcept
    : DrainageBasicInfo() {
    *this = ::std::move(from);
  }

  inline DrainageBasicInfo& operator=(const DrainageBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrainageBasicInfo& operator=(DrainageBasicInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrainageBasicInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrainageBasicInfo* internal_default_instance() {
    return reinterpret_cast<const DrainageBasicInfo*>(
               &_DrainageBasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DrainageBasicInfo& a, DrainageBasicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DrainageBasicInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrainageBasicInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrainageBasicInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrainageBasicInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DrainageBasicInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DrainageBasicInfo& from) {
    DrainageBasicInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrainageBasicInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.DrainageBasicInfo";
  }
  protected:
  explicit DrainageBasicInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAveragePowerFieldNumber = 1,
    kUndrainedVolumeFieldNumber = 2,
    kDrainedVolumeFieldNumber = 3,
    kAverageFlowFieldNumber = 4,
    kFloodedVolumeFieldNumber = 5,
  };
  // double average_power = 1 [json_name = "averagePower"];
  void clear_average_power() ;
  double average_power() const;
  void set_average_power(double value);

  private:
  double _internal_average_power() const;
  void _internal_set_average_power(double value);

  public:
  // double undrained_volume = 2 [json_name = "undrainedVolume"];
  void clear_undrained_volume() ;
  double undrained_volume() const;
  void set_undrained_volume(double value);

  private:
  double _internal_undrained_volume() const;
  void _internal_set_undrained_volume(double value);

  public:
  // double drained_volume = 3 [json_name = "drainedVolume"];
  void clear_drained_volume() ;
  double drained_volume() const;
  void set_drained_volume(double value);

  private:
  double _internal_drained_volume() const;
  void _internal_set_drained_volume(double value);

  public:
  // double average_flow = 4 [json_name = "averageFlow"];
  void clear_average_flow() ;
  double average_flow() const;
  void set_average_flow(double value);

  private:
  double _internal_average_flow() const;
  void _internal_set_average_flow(double value);

  public:
  // double flooded_volume = 5 [json_name = "floodedVolume"];
  void clear_flooded_volume() ;
  double flooded_volume() const;
  void set_flooded_volume(double value);

  private:
  double _internal_flooded_volume() const;
  void _internal_set_flooded_volume(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.DrainageBasicInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double average_power_;
    double undrained_volume_;
    double drained_volume_;
    double average_flow_;
    double flooded_volume_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class SupplyBasicInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.SupplyBasicInfo) */ {
 public:
  inline SupplyBasicInfo() : SupplyBasicInfo(nullptr) {}
  ~SupplyBasicInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SupplyBasicInfo(::google::protobuf::internal::ConstantInitialized);

  SupplyBasicInfo(const SupplyBasicInfo& from);
  SupplyBasicInfo(SupplyBasicInfo&& from) noexcept
    : SupplyBasicInfo() {
    *this = ::std::move(from);
  }

  inline SupplyBasicInfo& operator=(const SupplyBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyBasicInfo& operator=(SupplyBasicInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupplyBasicInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupplyBasicInfo* internal_default_instance() {
    return reinterpret_cast<const SupplyBasicInfo*>(
               &_SupplyBasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SupplyBasicInfo& a, SupplyBasicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyBasicInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyBasicInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupplyBasicInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupplyBasicInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SupplyBasicInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SupplyBasicInfo& from) {
    SupplyBasicInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyBasicInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.SupplyBasicInfo";
  }
  protected:
  explicit SupplyBasicInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAveragePowerFieldNumber = 1,
    kAverageFlowFieldNumber = 2,
  };
  // double average_power = 1 [json_name = "averagePower"];
  void clear_average_power() ;
  double average_power() const;
  void set_average_power(double value);

  private:
  double _internal_average_power() const;
  void _internal_set_average_power(double value);

  public:
  // double average_flow = 2 [json_name = "averageFlow"];
  void clear_average_flow() ;
  double average_flow() const;
  void set_average_flow(double value);

  private:
  double _internal_average_flow() const;
  void _internal_set_average_flow(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.SupplyBasicInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double average_power_;
    double average_flow_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class SupplyDemandStatistics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.SupplyDemandStatistics) */ {
 public:
  inline SupplyDemandStatistics() : SupplyDemandStatistics(nullptr) {}
  ~SupplyDemandStatistics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SupplyDemandStatistics(::google::protobuf::internal::ConstantInitialized);

  SupplyDemandStatistics(const SupplyDemandStatistics& from);
  SupplyDemandStatistics(SupplyDemandStatistics&& from) noexcept
    : SupplyDemandStatistics() {
    *this = ::std::move(from);
  }

  inline SupplyDemandStatistics& operator=(const SupplyDemandStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyDemandStatistics& operator=(SupplyDemandStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupplyDemandStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupplyDemandStatistics* internal_default_instance() {
    return reinterpret_cast<const SupplyDemandStatistics*>(
               &_SupplyDemandStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SupplyDemandStatistics& a, SupplyDemandStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyDemandStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyDemandStatistics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupplyDemandStatistics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupplyDemandStatistics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SupplyDemandStatistics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SupplyDemandStatistics& from) {
    SupplyDemandStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyDemandStatistics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.SupplyDemandStatistics";
  }
  protected:
  explicit SupplyDemandStatistics(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonsDemandFieldNumber = 1,
    kUnsatisfiedPersonsRatioFieldNumber = 3,
    kUnsatisfiedPersonsFieldNumber = 2,
    kUnsatisfiedAoisFieldNumber = 5,
    kAoisDemandFieldNumber = 4,
    kUnsatisfiedAoisRatioFieldNumber = 6,
  };
  // double persons_demand = 1 [json_name = "personsDemand"];
  void clear_persons_demand() ;
  double persons_demand() const;
  void set_persons_demand(double value);

  private:
  double _internal_persons_demand() const;
  void _internal_set_persons_demand(double value);

  public:
  // double unsatisfied_persons_ratio = 3 [json_name = "unsatisfiedPersonsRatio"];
  void clear_unsatisfied_persons_ratio() ;
  double unsatisfied_persons_ratio() const;
  void set_unsatisfied_persons_ratio(double value);

  private:
  double _internal_unsatisfied_persons_ratio() const;
  void _internal_set_unsatisfied_persons_ratio(double value);

  public:
  // int32 unsatisfied_persons = 2 [json_name = "unsatisfiedPersons"];
  void clear_unsatisfied_persons() ;
  ::int32_t unsatisfied_persons() const;
  void set_unsatisfied_persons(::int32_t value);

  private:
  ::int32_t _internal_unsatisfied_persons() const;
  void _internal_set_unsatisfied_persons(::int32_t value);

  public:
  // int32 unsatisfied_aois = 5 [json_name = "unsatisfiedAois"];
  void clear_unsatisfied_aois() ;
  ::int32_t unsatisfied_aois() const;
  void set_unsatisfied_aois(::int32_t value);

  private:
  ::int32_t _internal_unsatisfied_aois() const;
  void _internal_set_unsatisfied_aois(::int32_t value);

  public:
  // double aois_demand = 4 [json_name = "aoisDemand"];
  void clear_aois_demand() ;
  double aois_demand() const;
  void set_aois_demand(double value);

  private:
  double _internal_aois_demand() const;
  void _internal_set_aois_demand(double value);

  public:
  // double unsatisfied_aois_ratio = 6 [json_name = "unsatisfiedAoisRatio"];
  void clear_unsatisfied_aois_ratio() ;
  double unsatisfied_aois_ratio() const;
  void set_unsatisfied_aois_ratio(double value);

  private:
  double _internal_unsatisfied_aois_ratio() const;
  void _internal_set_unsatisfied_aois_ratio(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.SupplyDemandStatistics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double persons_demand_;
    double unsatisfied_persons_ratio_;
    ::int32_t unsatisfied_persons_;
    ::int32_t unsatisfied_aois_;
    double aois_demand_;
    double unsatisfied_aois_ratio_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class FailureStatistics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.FailureStatistics) */ {
 public:
  inline FailureStatistics() : FailureStatistics(nullptr) {}
  ~FailureStatistics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FailureStatistics(::google::protobuf::internal::ConstantInitialized);

  FailureStatistics(const FailureStatistics& from);
  FailureStatistics(FailureStatistics&& from) noexcept
    : FailureStatistics() {
    *this = ::std::move(from);
  }

  inline FailureStatistics& operator=(const FailureStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureStatistics& operator=(FailureStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureStatistics* internal_default_instance() {
    return reinterpret_cast<const FailureStatistics*>(
               &_FailureStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FailureStatistics& a, FailureStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureStatistics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureStatistics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureStatistics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FailureStatistics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FailureStatistics& from) {
    FailureStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailureStatistics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.FailureStatistics";
  }
  protected:
  explicit FailureStatistics(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailureNumFieldNumber = 1,
    kNormalNumFieldNumber = 2,
    kFailureRatioFieldNumber = 3,
  };
  // int32 failure_num = 1 [json_name = "failureNum"];
  void clear_failure_num() ;
  ::int32_t failure_num() const;
  void set_failure_num(::int32_t value);

  private:
  ::int32_t _internal_failure_num() const;
  void _internal_set_failure_num(::int32_t value);

  public:
  // int32 normal_num = 2 [json_name = "normalNum"];
  void clear_normal_num() ;
  ::int32_t normal_num() const;
  void set_normal_num(::int32_t value);

  private:
  ::int32_t _internal_normal_num() const;
  void _internal_set_normal_num(::int32_t value);

  public:
  // double failure_ratio = 3 [json_name = "failureRatio"];
  void clear_failure_ratio() ;
  double failure_ratio() const;
  void set_failure_ratio(double value);

  private:
  double _internal_failure_ratio() const;
  void _internal_set_failure_ratio(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.FailureStatistics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t failure_num_;
    ::int32_t normal_num_;
    double failure_ratio_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class DrainageMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.DrainageMetrics) */ {
 public:
  inline DrainageMetrics() : DrainageMetrics(nullptr) {}
  ~DrainageMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DrainageMetrics(::google::protobuf::internal::ConstantInitialized);

  DrainageMetrics(const DrainageMetrics& from);
  DrainageMetrics(DrainageMetrics&& from) noexcept
    : DrainageMetrics() {
    *this = ::std::move(from);
  }

  inline DrainageMetrics& operator=(const DrainageMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrainageMetrics& operator=(DrainageMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrainageMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrainageMetrics* internal_default_instance() {
    return reinterpret_cast<const DrainageMetrics*>(
               &_DrainageMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DrainageMetrics& a, DrainageMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(DrainageMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrainageMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrainageMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrainageMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DrainageMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DrainageMetrics& from) {
    DrainageMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrainageMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.DrainageMetrics";
  }
  protected:
  explicit DrainageMetrics(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrainageBasicInfoFieldNumber = 1,
    kFailureStatisticsFieldNumber = 3,
    kLoadRatioFieldNumber = 2,
  };
  // .city.water.output.v1.DrainageBasicInfo drainage_basic_info = 1 [json_name = "drainageBasicInfo"];
  bool has_drainage_basic_info() const;
  void clear_drainage_basic_info() ;
  const ::city::water::output::v1::DrainageBasicInfo& drainage_basic_info() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::DrainageBasicInfo* release_drainage_basic_info();
  ::city::water::output::v1::DrainageBasicInfo* mutable_drainage_basic_info();
  void set_allocated_drainage_basic_info(::city::water::output::v1::DrainageBasicInfo* value);
  void unsafe_arena_set_allocated_drainage_basic_info(::city::water::output::v1::DrainageBasicInfo* value);
  ::city::water::output::v1::DrainageBasicInfo* unsafe_arena_release_drainage_basic_info();

  private:
  const ::city::water::output::v1::DrainageBasicInfo& _internal_drainage_basic_info() const;
  ::city::water::output::v1::DrainageBasicInfo* _internal_mutable_drainage_basic_info();

  public:
  // .city.water.output.v1.FailureStatistics failure_statistics = 3 [json_name = "failureStatistics"];
  bool has_failure_statistics() const;
  void clear_failure_statistics() ;
  const ::city::water::output::v1::FailureStatistics& failure_statistics() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::FailureStatistics* release_failure_statistics();
  ::city::water::output::v1::FailureStatistics* mutable_failure_statistics();
  void set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value);
  void unsafe_arena_set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value);
  ::city::water::output::v1::FailureStatistics* unsafe_arena_release_failure_statistics();

  private:
  const ::city::water::output::v1::FailureStatistics& _internal_failure_statistics() const;
  ::city::water::output::v1::FailureStatistics* _internal_mutable_failure_statistics();

  public:
  // double load_ratio = 2 [json_name = "loadRatio"];
  void clear_load_ratio() ;
  double load_ratio() const;
  void set_load_ratio(double value);

  private:
  double _internal_load_ratio() const;
  void _internal_set_load_ratio(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.DrainageMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::water::output::v1::DrainageBasicInfo* drainage_basic_info_;
    ::city::water::output::v1::FailureStatistics* failure_statistics_;
    double load_ratio_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};// -------------------------------------------------------------------

class SupplyMetrics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.SupplyMetrics) */ {
 public:
  inline SupplyMetrics() : SupplyMetrics(nullptr) {}
  ~SupplyMetrics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SupplyMetrics(::google::protobuf::internal::ConstantInitialized);

  SupplyMetrics(const SupplyMetrics& from);
  SupplyMetrics(SupplyMetrics&& from) noexcept
    : SupplyMetrics() {
    *this = ::std::move(from);
  }

  inline SupplyMetrics& operator=(const SupplyMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyMetrics& operator=(SupplyMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupplyMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupplyMetrics* internal_default_instance() {
    return reinterpret_cast<const SupplyMetrics*>(
               &_SupplyMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SupplyMetrics& a, SupplyMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyMetrics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupplyMetrics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupplyMetrics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SupplyMetrics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SupplyMetrics& from) {
    SupplyMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyMetrics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "city.water.output.v1.SupplyMetrics";
  }
  protected:
  explicit SupplyMetrics(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupplyBasicInfoFieldNumber = 1,
    kSupplyDemandStatisticsFieldNumber = 2,
    kFailureStatisticsFieldNumber = 4,
    kLoadRatioFieldNumber = 3,
  };
  // .city.water.output.v1.SupplyBasicInfo supply_basic_info = 1 [json_name = "supplyBasicInfo"];
  bool has_supply_basic_info() const;
  void clear_supply_basic_info() ;
  const ::city::water::output::v1::SupplyBasicInfo& supply_basic_info() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::SupplyBasicInfo* release_supply_basic_info();
  ::city::water::output::v1::SupplyBasicInfo* mutable_supply_basic_info();
  void set_allocated_supply_basic_info(::city::water::output::v1::SupplyBasicInfo* value);
  void unsafe_arena_set_allocated_supply_basic_info(::city::water::output::v1::SupplyBasicInfo* value);
  ::city::water::output::v1::SupplyBasicInfo* unsafe_arena_release_supply_basic_info();

  private:
  const ::city::water::output::v1::SupplyBasicInfo& _internal_supply_basic_info() const;
  ::city::water::output::v1::SupplyBasicInfo* _internal_mutable_supply_basic_info();

  public:
  // .city.water.output.v1.SupplyDemandStatistics supply_demand_statistics = 2 [json_name = "supplyDemandStatistics"];
  bool has_supply_demand_statistics() const;
  void clear_supply_demand_statistics() ;
  const ::city::water::output::v1::SupplyDemandStatistics& supply_demand_statistics() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::SupplyDemandStatistics* release_supply_demand_statistics();
  ::city::water::output::v1::SupplyDemandStatistics* mutable_supply_demand_statistics();
  void set_allocated_supply_demand_statistics(::city::water::output::v1::SupplyDemandStatistics* value);
  void unsafe_arena_set_allocated_supply_demand_statistics(::city::water::output::v1::SupplyDemandStatistics* value);
  ::city::water::output::v1::SupplyDemandStatistics* unsafe_arena_release_supply_demand_statistics();

  private:
  const ::city::water::output::v1::SupplyDemandStatistics& _internal_supply_demand_statistics() const;
  ::city::water::output::v1::SupplyDemandStatistics* _internal_mutable_supply_demand_statistics();

  public:
  // .city.water.output.v1.FailureStatistics failure_statistics = 4 [json_name = "failureStatistics"];
  bool has_failure_statistics() const;
  void clear_failure_statistics() ;
  const ::city::water::output::v1::FailureStatistics& failure_statistics() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::FailureStatistics* release_failure_statistics();
  ::city::water::output::v1::FailureStatistics* mutable_failure_statistics();
  void set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value);
  void unsafe_arena_set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value);
  ::city::water::output::v1::FailureStatistics* unsafe_arena_release_failure_statistics();

  private:
  const ::city::water::output::v1::FailureStatistics& _internal_failure_statistics() const;
  ::city::water::output::v1::FailureStatistics* _internal_mutable_failure_statistics();

  public:
  // double load_ratio = 3 [json_name = "loadRatio"];
  void clear_load_ratio() ;
  double load_ratio() const;
  void set_load_ratio(double value);

  private:
  double _internal_load_ratio() const;
  void _internal_set_load_ratio(double value);

  public:
  // @@protoc_insertion_point(class_scope:city.water.output.v1.SupplyMetrics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::city::water::output::v1::SupplyBasicInfo* supply_basic_info_;
    ::city::water::output::v1::SupplyDemandStatistics* supply_demand_statistics_;
    ::city::water::output::v1::FailureStatistics* failure_statistics_;
    double load_ratio_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Road

// int32 id = 1 [json_name = "id"];
inline void Road::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Road::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Road.id)
  return _internal_id();
}
inline void Road::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Road.id)
}
inline ::int32_t Road::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Road::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// double depth = 2 [json_name = "depth"];
inline void Road::clear_depth() {
  _impl_.depth_ = 0;
}
inline double Road::depth() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Road.depth)
  return _internal_depth();
}
inline void Road::set_depth(double value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Road.depth)
}
inline double Road::_internal_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depth_;
}
inline void Road::_internal_set_depth(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.depth_ = value;
}

// -------------------------------------------------------------------

// RoadFlood

// .city.geo.v2.LongLatPosition position = 1 [json_name = "position"];
inline bool RoadFlood::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::city::geo::v2::LongLatPosition& RoadFlood::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::geo::v2::LongLatPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::geo::v2::LongLatPosition&>(::city::geo::v2::_LongLatPosition_default_instance_);
}
inline const ::city::geo::v2::LongLatPosition& RoadFlood::position() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.RoadFlood.position)
  return _internal_position();
}
inline void RoadFlood::unsafe_arena_set_allocated_position(::city::geo::v2::LongLatPosition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::city::geo::v2::LongLatPosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.RoadFlood.position)
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::geo::v2::LongLatPosition* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.RoadFlood.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::geo::v2::LongLatPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::geo::v2::LongLatPosition>(GetArenaForAllocation());
    _impl_.position_ = reinterpret_cast<::city::geo::v2::LongLatPosition*>(p);
  }
  return _impl_.position_;
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::mutable_position() {
  ::city::geo::v2::LongLatPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.RoadFlood.position)
  return _msg;
}
inline void RoadFlood::set_allocated_position(::city::geo::v2::LongLatPosition* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::city::geo::v2::LongLatPosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.RoadFlood.position)
}

// double depth = 2 [json_name = "depth"];
inline void RoadFlood::clear_depth() {
  _impl_.depth_ = 0;
}
inline double RoadFlood::depth() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.RoadFlood.depth)
  return _internal_depth();
}
inline void RoadFlood::set_depth(double value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.RoadFlood.depth)
}
inline double RoadFlood::_internal_depth() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depth_;
}
inline void RoadFlood::_internal_set_depth(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.depth_ = value;
}

// -------------------------------------------------------------------

// DetailedRoad

// int32 id = 1 [json_name = "id"];
inline void DetailedRoad::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t DetailedRoad::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DetailedRoad.id)
  return _internal_id();
}
inline void DetailedRoad::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DetailedRoad.id)
}
inline ::int32_t DetailedRoad::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void DetailedRoad::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// repeated .city.water.output.v1.RoadFlood depths = 2 [json_name = "depths"];
inline int DetailedRoad::_internal_depths_size() const {
  return _internal_depths().size();
}
inline int DetailedRoad::depths_size() const {
  return _internal_depths_size();
}
inline void DetailedRoad::clear_depths() {
  _internal_mutable_depths()->Clear();
}
inline ::city::water::output::v1::RoadFlood* DetailedRoad::mutable_depths(int index) {
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.DetailedRoad.depths)
  return _internal_mutable_depths()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::city::water::output::v1::RoadFlood >*
DetailedRoad::mutable_depths() {
  // @@protoc_insertion_point(field_mutable_list:city.water.output.v1.DetailedRoad.depths)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_depths();
}
inline const ::city::water::output::v1::RoadFlood& DetailedRoad::depths(int index) const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DetailedRoad.depths)
    return _internal_depths().Get(index);
}
inline ::city::water::output::v1::RoadFlood* DetailedRoad::add_depths() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::city::water::output::v1::RoadFlood* _add = _internal_mutable_depths()->Add();
  // @@protoc_insertion_point(field_add:city.water.output.v1.DetailedRoad.depths)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::city::water::output::v1::RoadFlood >&
DetailedRoad::depths() const {
  // @@protoc_insertion_point(field_list:city.water.output.v1.DetailedRoad.depths)
  return _internal_depths();
}
inline const ::google::protobuf::RepeatedPtrField<::city::water::output::v1::RoadFlood>&
DetailedRoad::_internal_depths() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.depths_;
}
inline ::google::protobuf::RepeatedPtrField<::city::water::output::v1::RoadFlood>*
DetailedRoad::_internal_mutable_depths() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.depths_;
}

// -------------------------------------------------------------------

// Node

// string id = 1 [json_name = "id"];
inline void Node::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Node.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Node::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:city.water.output.v1.Node.id)
}
inline std::string* Node::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.Node.id)
  return _s;
}
inline const std::string& Node::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Node::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Node::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.Node.id)
  return _impl_.id_.Release();
}
inline void Node::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.Node.id)
}

// double head = 2 [json_name = "head"];
inline void Node::clear_head() {
  _impl_.head_ = 0;
}
inline double Node::head() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Node.head)
  return _internal_head();
}
inline void Node::set_head(double value) {
  _internal_set_head(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Node.head)
}
inline double Node::_internal_head() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.head_;
}
inline void Node::_internal_set_head(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.head_ = value;
}

// -------------------------------------------------------------------

// Link

// string id = 1 [json_name = "id"];
inline void Link::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Link::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Link::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.id)
}
inline std::string* Link::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.Link.id)
  return _s;
}
inline const std::string& Link::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Link::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Link::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.Link.id)
  return _impl_.id_.Release();
}
inline void Link::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.Link.id)
}

// .city.water.output.v1.LinkType type = 2 [json_name = "type"];
inline void Link::clear_type() {
  _impl_.type_ = 0;
}
inline ::city::water::output::v1::LinkType Link::type() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.type)
  return _internal_type();
}
inline void Link::set_type(::city::water::output::v1::LinkType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.type)
}
inline ::city::water::output::v1::LinkType Link::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::city::water::output::v1::LinkType>(_impl_.type_);
}
inline void Link::_internal_set_type(::city::water::output::v1::LinkType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// double flow = 3 [json_name = "flow"];
inline void Link::clear_flow() {
  _impl_.flow_ = 0;
}
inline double Link::flow() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.flow)
  return _internal_flow();
}
inline void Link::set_flow(double value) {
  _internal_set_flow(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.flow)
}
inline double Link::_internal_flow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flow_;
}
inline void Link::_internal_set_flow(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flow_ = value;
}

// bool ok = 4 [json_name = "ok"];
inline void Link::clear_ok() {
  _impl_.ok_ = false;
}
inline bool Link::ok() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.ok)
  return _internal_ok();
}
inline void Link::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.ok)
}
inline bool Link::_internal_ok() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ok_;
}
inline void Link::_internal_set_ok(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ok_ = value;
}

// -------------------------------------------------------------------

// Aoi

// int32 id = 1 [json_name = "id"];
inline void Aoi::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Aoi::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.id)
  return _internal_id();
}
inline void Aoi::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.id)
}
inline ::int32_t Aoi::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Aoi::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 unsatisfied_num = 2 [json_name = "unsatisfiedNum"];
inline void Aoi::clear_unsatisfied_num() {
  _impl_.unsatisfied_num_ = 0;
}
inline ::int32_t Aoi::unsatisfied_num() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.unsatisfied_num)
  return _internal_unsatisfied_num();
}
inline void Aoi::set_unsatisfied_num(::int32_t value) {
  _internal_set_unsatisfied_num(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.unsatisfied_num)
}
inline ::int32_t Aoi::_internal_unsatisfied_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unsatisfied_num_;
}
inline void Aoi::_internal_set_unsatisfied_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unsatisfied_num_ = value;
}

// double unsatisfied_ratio = 3 [json_name = "unsatisfiedRatio"];
inline void Aoi::clear_unsatisfied_ratio() {
  _impl_.unsatisfied_ratio_ = 0;
}
inline double Aoi::unsatisfied_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.unsatisfied_ratio)
  return _internal_unsatisfied_ratio();
}
inline void Aoi::set_unsatisfied_ratio(double value) {
  _internal_set_unsatisfied_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.unsatisfied_ratio)
}
inline double Aoi::_internal_unsatisfied_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unsatisfied_ratio_;
}
inline void Aoi::_internal_set_unsatisfied_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unsatisfied_ratio_ = value;
}

// double demand = 4 [json_name = "demand"];
inline void Aoi::clear_demand() {
  _impl_.demand_ = 0;
}
inline double Aoi::demand() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.demand)
  return _internal_demand();
}
inline void Aoi::set_demand(double value) {
  _internal_set_demand(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.demand)
}
inline double Aoi::_internal_demand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.demand_;
}
inline void Aoi::_internal_set_demand(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.demand_ = value;
}

// double supply = 5 [json_name = "supply"];
inline void Aoi::clear_supply() {
  _impl_.supply_ = 0;
}
inline double Aoi::supply() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.supply)
  return _internal_supply();
}
inline void Aoi::set_supply(double value) {
  _internal_set_supply(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.supply)
}
inline double Aoi::_internal_supply() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supply_;
}
inline void Aoi::_internal_set_supply(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.supply_ = value;
}

// -------------------------------------------------------------------

// DrainageBasicInfo

// double average_power = 1 [json_name = "averagePower"];
inline void DrainageBasicInfo::clear_average_power() {
  _impl_.average_power_ = 0;
}
inline double DrainageBasicInfo::average_power() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.average_power)
  return _internal_average_power();
}
inline void DrainageBasicInfo::set_average_power(double value) {
  _internal_set_average_power(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.average_power)
}
inline double DrainageBasicInfo::_internal_average_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_power_;
}
inline void DrainageBasicInfo::_internal_set_average_power(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_power_ = value;
}

// double undrained_volume = 2 [json_name = "undrainedVolume"];
inline void DrainageBasicInfo::clear_undrained_volume() {
  _impl_.undrained_volume_ = 0;
}
inline double DrainageBasicInfo::undrained_volume() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.undrained_volume)
  return _internal_undrained_volume();
}
inline void DrainageBasicInfo::set_undrained_volume(double value) {
  _internal_set_undrained_volume(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.undrained_volume)
}
inline double DrainageBasicInfo::_internal_undrained_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.undrained_volume_;
}
inline void DrainageBasicInfo::_internal_set_undrained_volume(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.undrained_volume_ = value;
}

// double drained_volume = 3 [json_name = "drainedVolume"];
inline void DrainageBasicInfo::clear_drained_volume() {
  _impl_.drained_volume_ = 0;
}
inline double DrainageBasicInfo::drained_volume() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.drained_volume)
  return _internal_drained_volume();
}
inline void DrainageBasicInfo::set_drained_volume(double value) {
  _internal_set_drained_volume(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.drained_volume)
}
inline double DrainageBasicInfo::_internal_drained_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drained_volume_;
}
inline void DrainageBasicInfo::_internal_set_drained_volume(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.drained_volume_ = value;
}

// double average_flow = 4 [json_name = "averageFlow"];
inline void DrainageBasicInfo::clear_average_flow() {
  _impl_.average_flow_ = 0;
}
inline double DrainageBasicInfo::average_flow() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.average_flow)
  return _internal_average_flow();
}
inline void DrainageBasicInfo::set_average_flow(double value) {
  _internal_set_average_flow(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.average_flow)
}
inline double DrainageBasicInfo::_internal_average_flow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_flow_;
}
inline void DrainageBasicInfo::_internal_set_average_flow(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_flow_ = value;
}

// double flooded_volume = 5 [json_name = "floodedVolume"];
inline void DrainageBasicInfo::clear_flooded_volume() {
  _impl_.flooded_volume_ = 0;
}
inline double DrainageBasicInfo::flooded_volume() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.flooded_volume)
  return _internal_flooded_volume();
}
inline void DrainageBasicInfo::set_flooded_volume(double value) {
  _internal_set_flooded_volume(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.flooded_volume)
}
inline double DrainageBasicInfo::_internal_flooded_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flooded_volume_;
}
inline void DrainageBasicInfo::_internal_set_flooded_volume(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.flooded_volume_ = value;
}

// -------------------------------------------------------------------

// SupplyBasicInfo

// double average_power = 1 [json_name = "averagePower"];
inline void SupplyBasicInfo::clear_average_power() {
  _impl_.average_power_ = 0;
}
inline double SupplyBasicInfo::average_power() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyBasicInfo.average_power)
  return _internal_average_power();
}
inline void SupplyBasicInfo::set_average_power(double value) {
  _internal_set_average_power(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyBasicInfo.average_power)
}
inline double SupplyBasicInfo::_internal_average_power() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_power_;
}
inline void SupplyBasicInfo::_internal_set_average_power(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_power_ = value;
}

// double average_flow = 2 [json_name = "averageFlow"];
inline void SupplyBasicInfo::clear_average_flow() {
  _impl_.average_flow_ = 0;
}
inline double SupplyBasicInfo::average_flow() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyBasicInfo.average_flow)
  return _internal_average_flow();
}
inline void SupplyBasicInfo::set_average_flow(double value) {
  _internal_set_average_flow(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyBasicInfo.average_flow)
}
inline double SupplyBasicInfo::_internal_average_flow() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_flow_;
}
inline void SupplyBasicInfo::_internal_set_average_flow(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_flow_ = value;
}

// -------------------------------------------------------------------

// SupplyDemandStatistics

// double persons_demand = 1 [json_name = "personsDemand"];
inline void SupplyDemandStatistics::clear_persons_demand() {
  _impl_.persons_demand_ = 0;
}
inline double SupplyDemandStatistics::persons_demand() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.persons_demand)
  return _internal_persons_demand();
}
inline void SupplyDemandStatistics::set_persons_demand(double value) {
  _internal_set_persons_demand(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.persons_demand)
}
inline double SupplyDemandStatistics::_internal_persons_demand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.persons_demand_;
}
inline void SupplyDemandStatistics::_internal_set_persons_demand(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.persons_demand_ = value;
}

// int32 unsatisfied_persons = 2 [json_name = "unsatisfiedPersons"];
inline void SupplyDemandStatistics::clear_unsatisfied_persons() {
  _impl_.unsatisfied_persons_ = 0;
}
inline ::int32_t SupplyDemandStatistics::unsatisfied_persons() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons)
  return _internal_unsatisfied_persons();
}
inline void SupplyDemandStatistics::set_unsatisfied_persons(::int32_t value) {
  _internal_set_unsatisfied_persons(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons)
}
inline ::int32_t SupplyDemandStatistics::_internal_unsatisfied_persons() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unsatisfied_persons_;
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_persons(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unsatisfied_persons_ = value;
}

// double unsatisfied_persons_ratio = 3 [json_name = "unsatisfiedPersonsRatio"];
inline void SupplyDemandStatistics::clear_unsatisfied_persons_ratio() {
  _impl_.unsatisfied_persons_ratio_ = 0;
}
inline double SupplyDemandStatistics::unsatisfied_persons_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons_ratio)
  return _internal_unsatisfied_persons_ratio();
}
inline void SupplyDemandStatistics::set_unsatisfied_persons_ratio(double value) {
  _internal_set_unsatisfied_persons_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons_ratio)
}
inline double SupplyDemandStatistics::_internal_unsatisfied_persons_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unsatisfied_persons_ratio_;
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_persons_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unsatisfied_persons_ratio_ = value;
}

// double aois_demand = 4 [json_name = "aoisDemand"];
inline void SupplyDemandStatistics::clear_aois_demand() {
  _impl_.aois_demand_ = 0;
}
inline double SupplyDemandStatistics::aois_demand() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.aois_demand)
  return _internal_aois_demand();
}
inline void SupplyDemandStatistics::set_aois_demand(double value) {
  _internal_set_aois_demand(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.aois_demand)
}
inline double SupplyDemandStatistics::_internal_aois_demand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aois_demand_;
}
inline void SupplyDemandStatistics::_internal_set_aois_demand(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aois_demand_ = value;
}

// int32 unsatisfied_aois = 5 [json_name = "unsatisfiedAois"];
inline void SupplyDemandStatistics::clear_unsatisfied_aois() {
  _impl_.unsatisfied_aois_ = 0;
}
inline ::int32_t SupplyDemandStatistics::unsatisfied_aois() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois)
  return _internal_unsatisfied_aois();
}
inline void SupplyDemandStatistics::set_unsatisfied_aois(::int32_t value) {
  _internal_set_unsatisfied_aois(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois)
}
inline ::int32_t SupplyDemandStatistics::_internal_unsatisfied_aois() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unsatisfied_aois_;
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_aois(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unsatisfied_aois_ = value;
}

// double unsatisfied_aois_ratio = 6 [json_name = "unsatisfiedAoisRatio"];
inline void SupplyDemandStatistics::clear_unsatisfied_aois_ratio() {
  _impl_.unsatisfied_aois_ratio_ = 0;
}
inline double SupplyDemandStatistics::unsatisfied_aois_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois_ratio)
  return _internal_unsatisfied_aois_ratio();
}
inline void SupplyDemandStatistics::set_unsatisfied_aois_ratio(double value) {
  _internal_set_unsatisfied_aois_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois_ratio)
}
inline double SupplyDemandStatistics::_internal_unsatisfied_aois_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unsatisfied_aois_ratio_;
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_aois_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unsatisfied_aois_ratio_ = value;
}

// -------------------------------------------------------------------

// FailureStatistics

// int32 failure_num = 1 [json_name = "failureNum"];
inline void FailureStatistics::clear_failure_num() {
  _impl_.failure_num_ = 0;
}
inline ::int32_t FailureStatistics::failure_num() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.FailureStatistics.failure_num)
  return _internal_failure_num();
}
inline void FailureStatistics::set_failure_num(::int32_t value) {
  _internal_set_failure_num(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.FailureStatistics.failure_num)
}
inline ::int32_t FailureStatistics::_internal_failure_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.failure_num_;
}
inline void FailureStatistics::_internal_set_failure_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.failure_num_ = value;
}

// int32 normal_num = 2 [json_name = "normalNum"];
inline void FailureStatistics::clear_normal_num() {
  _impl_.normal_num_ = 0;
}
inline ::int32_t FailureStatistics::normal_num() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.FailureStatistics.normal_num)
  return _internal_normal_num();
}
inline void FailureStatistics::set_normal_num(::int32_t value) {
  _internal_set_normal_num(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.FailureStatistics.normal_num)
}
inline ::int32_t FailureStatistics::_internal_normal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.normal_num_;
}
inline void FailureStatistics::_internal_set_normal_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.normal_num_ = value;
}

// double failure_ratio = 3 [json_name = "failureRatio"];
inline void FailureStatistics::clear_failure_ratio() {
  _impl_.failure_ratio_ = 0;
}
inline double FailureStatistics::failure_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.FailureStatistics.failure_ratio)
  return _internal_failure_ratio();
}
inline void FailureStatistics::set_failure_ratio(double value) {
  _internal_set_failure_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.FailureStatistics.failure_ratio)
}
inline double FailureStatistics::_internal_failure_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.failure_ratio_;
}
inline void FailureStatistics::_internal_set_failure_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.failure_ratio_ = value;
}

// -------------------------------------------------------------------

// DrainageMetrics

// .city.water.output.v1.DrainageBasicInfo drainage_basic_info = 1 [json_name = "drainageBasicInfo"];
inline bool DrainageMetrics::has_drainage_basic_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drainage_basic_info_ != nullptr);
  return value;
}
inline void DrainageMetrics::clear_drainage_basic_info() {
  if (_impl_.drainage_basic_info_ != nullptr) _impl_.drainage_basic_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::city::water::output::v1::DrainageBasicInfo& DrainageMetrics::_internal_drainage_basic_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::water::output::v1::DrainageBasicInfo* p = _impl_.drainage_basic_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::DrainageBasicInfo&>(::city::water::output::v1::_DrainageBasicInfo_default_instance_);
}
inline const ::city::water::output::v1::DrainageBasicInfo& DrainageMetrics::drainage_basic_info() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageMetrics.drainage_basic_info)
  return _internal_drainage_basic_info();
}
inline void DrainageMetrics::unsafe_arena_set_allocated_drainage_basic_info(::city::water::output::v1::DrainageBasicInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.drainage_basic_info_);
  }
  _impl_.drainage_basic_info_ = reinterpret_cast<::city::water::output::v1::DrainageBasicInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.DrainageMetrics.drainage_basic_info)
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::release_drainage_basic_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::water::output::v1::DrainageBasicInfo* released = _impl_.drainage_basic_info_;
  _impl_.drainage_basic_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::unsafe_arena_release_drainage_basic_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.DrainageMetrics.drainage_basic_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::water::output::v1::DrainageBasicInfo* temp = _impl_.drainage_basic_info_;
  _impl_.drainage_basic_info_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::_internal_mutable_drainage_basic_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drainage_basic_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::DrainageBasicInfo>(GetArenaForAllocation());
    _impl_.drainage_basic_info_ = reinterpret_cast<::city::water::output::v1::DrainageBasicInfo*>(p);
  }
  return _impl_.drainage_basic_info_;
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::mutable_drainage_basic_info() {
  ::city::water::output::v1::DrainageBasicInfo* _msg = _internal_mutable_drainage_basic_info();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.DrainageMetrics.drainage_basic_info)
  return _msg;
}
inline void DrainageMetrics::set_allocated_drainage_basic_info(::city::water::output::v1::DrainageBasicInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::water::output::v1::DrainageBasicInfo*>(_impl_.drainage_basic_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::water::output::v1::DrainageBasicInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.drainage_basic_info_ = reinterpret_cast<::city::water::output::v1::DrainageBasicInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.DrainageMetrics.drainage_basic_info)
}

// double load_ratio = 2 [json_name = "loadRatio"];
inline void DrainageMetrics::clear_load_ratio() {
  _impl_.load_ratio_ = 0;
}
inline double DrainageMetrics::load_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageMetrics.load_ratio)
  return _internal_load_ratio();
}
inline void DrainageMetrics::set_load_ratio(double value) {
  _internal_set_load_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageMetrics.load_ratio)
}
inline double DrainageMetrics::_internal_load_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.load_ratio_;
}
inline void DrainageMetrics::_internal_set_load_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.load_ratio_ = value;
}

// .city.water.output.v1.FailureStatistics failure_statistics = 3 [json_name = "failureStatistics"];
inline bool DrainageMetrics::has_failure_statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.failure_statistics_ != nullptr);
  return value;
}
inline void DrainageMetrics::clear_failure_statistics() {
  if (_impl_.failure_statistics_ != nullptr) _impl_.failure_statistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::city::water::output::v1::FailureStatistics& DrainageMetrics::_internal_failure_statistics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::water::output::v1::FailureStatistics* p = _impl_.failure_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::FailureStatistics&>(::city::water::output::v1::_FailureStatistics_default_instance_);
}
inline const ::city::water::output::v1::FailureStatistics& DrainageMetrics::failure_statistics() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageMetrics.failure_statistics)
  return _internal_failure_statistics();
}
inline void DrainageMetrics::unsafe_arena_set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.failure_statistics_);
  }
  _impl_.failure_statistics_ = reinterpret_cast<::city::water::output::v1::FailureStatistics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.DrainageMetrics.failure_statistics)
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::release_failure_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::water::output::v1::FailureStatistics* released = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::unsafe_arena_release_failure_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.DrainageMetrics.failure_statistics)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::water::output::v1::FailureStatistics* temp = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::_internal_mutable_failure_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.failure_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::FailureStatistics>(GetArenaForAllocation());
    _impl_.failure_statistics_ = reinterpret_cast<::city::water::output::v1::FailureStatistics*>(p);
  }
  return _impl_.failure_statistics_;
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::mutable_failure_statistics() {
  ::city::water::output::v1::FailureStatistics* _msg = _internal_mutable_failure_statistics();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.DrainageMetrics.failure_statistics)
  return _msg;
}
inline void DrainageMetrics::set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::water::output::v1::FailureStatistics*>(_impl_.failure_statistics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::water::output::v1::FailureStatistics*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.failure_statistics_ = reinterpret_cast<::city::water::output::v1::FailureStatistics*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.DrainageMetrics.failure_statistics)
}

// -------------------------------------------------------------------

// SupplyMetrics

// .city.water.output.v1.SupplyBasicInfo supply_basic_info = 1 [json_name = "supplyBasicInfo"];
inline bool SupplyMetrics::has_supply_basic_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.supply_basic_info_ != nullptr);
  return value;
}
inline void SupplyMetrics::clear_supply_basic_info() {
  if (_impl_.supply_basic_info_ != nullptr) _impl_.supply_basic_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::city::water::output::v1::SupplyBasicInfo& SupplyMetrics::_internal_supply_basic_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::water::output::v1::SupplyBasicInfo* p = _impl_.supply_basic_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::SupplyBasicInfo&>(::city::water::output::v1::_SupplyBasicInfo_default_instance_);
}
inline const ::city::water::output::v1::SupplyBasicInfo& SupplyMetrics::supply_basic_info() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.supply_basic_info)
  return _internal_supply_basic_info();
}
inline void SupplyMetrics::unsafe_arena_set_allocated_supply_basic_info(::city::water::output::v1::SupplyBasicInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supply_basic_info_);
  }
  _impl_.supply_basic_info_ = reinterpret_cast<::city::water::output::v1::SupplyBasicInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.SupplyMetrics.supply_basic_info)
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::release_supply_basic_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::water::output::v1::SupplyBasicInfo* released = _impl_.supply_basic_info_;
  _impl_.supply_basic_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::unsafe_arena_release_supply_basic_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.SupplyMetrics.supply_basic_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::city::water::output::v1::SupplyBasicInfo* temp = _impl_.supply_basic_info_;
  _impl_.supply_basic_info_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::_internal_mutable_supply_basic_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.supply_basic_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::SupplyBasicInfo>(GetArenaForAllocation());
    _impl_.supply_basic_info_ = reinterpret_cast<::city::water::output::v1::SupplyBasicInfo*>(p);
  }
  return _impl_.supply_basic_info_;
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::mutable_supply_basic_info() {
  ::city::water::output::v1::SupplyBasicInfo* _msg = _internal_mutable_supply_basic_info();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.SupplyMetrics.supply_basic_info)
  return _msg;
}
inline void SupplyMetrics::set_allocated_supply_basic_info(::city::water::output::v1::SupplyBasicInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::water::output::v1::SupplyBasicInfo*>(_impl_.supply_basic_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::water::output::v1::SupplyBasicInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.supply_basic_info_ = reinterpret_cast<::city::water::output::v1::SupplyBasicInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.SupplyMetrics.supply_basic_info)
}

// .city.water.output.v1.SupplyDemandStatistics supply_demand_statistics = 2 [json_name = "supplyDemandStatistics"];
inline bool SupplyMetrics::has_supply_demand_statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.supply_demand_statistics_ != nullptr);
  return value;
}
inline void SupplyMetrics::clear_supply_demand_statistics() {
  if (_impl_.supply_demand_statistics_ != nullptr) _impl_.supply_demand_statistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::city::water::output::v1::SupplyDemandStatistics& SupplyMetrics::_internal_supply_demand_statistics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::water::output::v1::SupplyDemandStatistics* p = _impl_.supply_demand_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::SupplyDemandStatistics&>(::city::water::output::v1::_SupplyDemandStatistics_default_instance_);
}
inline const ::city::water::output::v1::SupplyDemandStatistics& SupplyMetrics::supply_demand_statistics() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
  return _internal_supply_demand_statistics();
}
inline void SupplyMetrics::unsafe_arena_set_allocated_supply_demand_statistics(::city::water::output::v1::SupplyDemandStatistics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.supply_demand_statistics_);
  }
  _impl_.supply_demand_statistics_ = reinterpret_cast<::city::water::output::v1::SupplyDemandStatistics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::release_supply_demand_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::water::output::v1::SupplyDemandStatistics* released = _impl_.supply_demand_statistics_;
  _impl_.supply_demand_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::unsafe_arena_release_supply_demand_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.SupplyMetrics.supply_demand_statistics)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::city::water::output::v1::SupplyDemandStatistics* temp = _impl_.supply_demand_statistics_;
  _impl_.supply_demand_statistics_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::_internal_mutable_supply_demand_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.supply_demand_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::SupplyDemandStatistics>(GetArenaForAllocation());
    _impl_.supply_demand_statistics_ = reinterpret_cast<::city::water::output::v1::SupplyDemandStatistics*>(p);
  }
  return _impl_.supply_demand_statistics_;
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::mutable_supply_demand_statistics() {
  ::city::water::output::v1::SupplyDemandStatistics* _msg = _internal_mutable_supply_demand_statistics();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
  return _msg;
}
inline void SupplyMetrics::set_allocated_supply_demand_statistics(::city::water::output::v1::SupplyDemandStatistics* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::water::output::v1::SupplyDemandStatistics*>(_impl_.supply_demand_statistics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::water::output::v1::SupplyDemandStatistics*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.supply_demand_statistics_ = reinterpret_cast<::city::water::output::v1::SupplyDemandStatistics*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
}

// double load_ratio = 3 [json_name = "loadRatio"];
inline void SupplyMetrics::clear_load_ratio() {
  _impl_.load_ratio_ = 0;
}
inline double SupplyMetrics::load_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.load_ratio)
  return _internal_load_ratio();
}
inline void SupplyMetrics::set_load_ratio(double value) {
  _internal_set_load_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyMetrics.load_ratio)
}
inline double SupplyMetrics::_internal_load_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.load_ratio_;
}
inline void SupplyMetrics::_internal_set_load_ratio(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.load_ratio_ = value;
}

// .city.water.output.v1.FailureStatistics failure_statistics = 4 [json_name = "failureStatistics"];
inline bool SupplyMetrics::has_failure_statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.failure_statistics_ != nullptr);
  return value;
}
inline void SupplyMetrics::clear_failure_statistics() {
  if (_impl_.failure_statistics_ != nullptr) _impl_.failure_statistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::city::water::output::v1::FailureStatistics& SupplyMetrics::_internal_failure_statistics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::city::water::output::v1::FailureStatistics* p = _impl_.failure_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::FailureStatistics&>(::city::water::output::v1::_FailureStatistics_default_instance_);
}
inline const ::city::water::output::v1::FailureStatistics& SupplyMetrics::failure_statistics() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.failure_statistics)
  return _internal_failure_statistics();
}
inline void SupplyMetrics::unsafe_arena_set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.failure_statistics_);
  }
  _impl_.failure_statistics_ = reinterpret_cast<::city::water::output::v1::FailureStatistics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.SupplyMetrics.failure_statistics)
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::release_failure_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::water::output::v1::FailureStatistics* released = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::unsafe_arena_release_failure_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:city.water.output.v1.SupplyMetrics.failure_statistics)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::city::water::output::v1::FailureStatistics* temp = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::_internal_mutable_failure_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.failure_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::FailureStatistics>(GetArenaForAllocation());
    _impl_.failure_statistics_ = reinterpret_cast<::city::water::output::v1::FailureStatistics*>(p);
  }
  return _impl_.failure_statistics_;
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::mutable_failure_statistics() {
  ::city::water::output::v1::FailureStatistics* _msg = _internal_mutable_failure_statistics();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.SupplyMetrics.failure_statistics)
  return _msg;
}
inline void SupplyMetrics::set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::city::water::output::v1::FailureStatistics*>(_impl_.failure_statistics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::city::water::output::v1::FailureStatistics*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.failure_statistics_ = reinterpret_cast<::city::water::output::v1::FailureStatistics*>(value);
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.SupplyMetrics.failure_statistics)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace output
}  // namespace water
}  // namespace city


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::city::water::output::v1::LinkType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::city::water::output::v1::LinkType>() {
  return ::city::water::output::v1::LinkType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_city_2fwater_2foutput_2fv1_2foutput_2eproto_2epb_2eh

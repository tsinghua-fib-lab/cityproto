// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: city/water/output/v1/output.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_city_2fwater_2foutput_2fv1_2foutput_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_city_2fwater_2foutput_2fv1_2foutput_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "city/geo/v2/geo.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_city_2fwater_2foutput_2fv1_2foutput_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_city_2fwater_2foutput_2fv1_2foutput_2eproto;
namespace city {
namespace water {
namespace output {
namespace v1 {
class Aoi;
struct AoiDefaultTypeInternal;
extern AoiDefaultTypeInternal _Aoi_default_instance_;
class DetailedRoad;
struct DetailedRoadDefaultTypeInternal;
extern DetailedRoadDefaultTypeInternal _DetailedRoad_default_instance_;
class DrainageBasicInfo;
struct DrainageBasicInfoDefaultTypeInternal;
extern DrainageBasicInfoDefaultTypeInternal _DrainageBasicInfo_default_instance_;
class DrainageMetrics;
struct DrainageMetricsDefaultTypeInternal;
extern DrainageMetricsDefaultTypeInternal _DrainageMetrics_default_instance_;
class FailureStatistics;
struct FailureStatisticsDefaultTypeInternal;
extern FailureStatisticsDefaultTypeInternal _FailureStatistics_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Road;
struct RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadFlood;
struct RoadFloodDefaultTypeInternal;
extern RoadFloodDefaultTypeInternal _RoadFlood_default_instance_;
class SupplyBasicInfo;
struct SupplyBasicInfoDefaultTypeInternal;
extern SupplyBasicInfoDefaultTypeInternal _SupplyBasicInfo_default_instance_;
class SupplyDemandStatistics;
struct SupplyDemandStatisticsDefaultTypeInternal;
extern SupplyDemandStatisticsDefaultTypeInternal _SupplyDemandStatistics_default_instance_;
class SupplyMetrics;
struct SupplyMetricsDefaultTypeInternal;
extern SupplyMetricsDefaultTypeInternal _SupplyMetrics_default_instance_;
}  // namespace v1
}  // namespace output
}  // namespace water
}  // namespace city
PROTOBUF_NAMESPACE_OPEN
template<> ::city::water::output::v1::Aoi* Arena::CreateMaybeMessage<::city::water::output::v1::Aoi>(Arena*);
template<> ::city::water::output::v1::DetailedRoad* Arena::CreateMaybeMessage<::city::water::output::v1::DetailedRoad>(Arena*);
template<> ::city::water::output::v1::DrainageBasicInfo* Arena::CreateMaybeMessage<::city::water::output::v1::DrainageBasicInfo>(Arena*);
template<> ::city::water::output::v1::DrainageMetrics* Arena::CreateMaybeMessage<::city::water::output::v1::DrainageMetrics>(Arena*);
template<> ::city::water::output::v1::FailureStatistics* Arena::CreateMaybeMessage<::city::water::output::v1::FailureStatistics>(Arena*);
template<> ::city::water::output::v1::Link* Arena::CreateMaybeMessage<::city::water::output::v1::Link>(Arena*);
template<> ::city::water::output::v1::Node* Arena::CreateMaybeMessage<::city::water::output::v1::Node>(Arena*);
template<> ::city::water::output::v1::Road* Arena::CreateMaybeMessage<::city::water::output::v1::Road>(Arena*);
template<> ::city::water::output::v1::RoadFlood* Arena::CreateMaybeMessage<::city::water::output::v1::RoadFlood>(Arena*);
template<> ::city::water::output::v1::SupplyBasicInfo* Arena::CreateMaybeMessage<::city::water::output::v1::SupplyBasicInfo>(Arena*);
template<> ::city::water::output::v1::SupplyDemandStatistics* Arena::CreateMaybeMessage<::city::water::output::v1::SupplyDemandStatistics>(Arena*);
template<> ::city::water::output::v1::SupplyMetrics* Arena::CreateMaybeMessage<::city::water::output::v1::SupplyMetrics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace city {
namespace water {
namespace output {
namespace v1 {

enum LinkType : int {
  LINK_TYPE_UNSPECIFIED = 0,
  LINK_TYPE_PIPE = 1,
  LINK_TYPE_PUMP = 2,
  LinkType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LinkType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LinkType_IsValid(int value);
constexpr LinkType LinkType_MIN = LINK_TYPE_UNSPECIFIED;
constexpr LinkType LinkType_MAX = LINK_TYPE_PUMP;
constexpr int LinkType_ARRAYSIZE = LinkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LinkType_descriptor();
template<typename T>
inline const std::string& LinkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LinkType_descriptor(), enum_t_value);
}
inline bool LinkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LinkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LinkType>(
    LinkType_descriptor(), name, value);
}
// ===================================================================

class Road final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Road) */ {
 public:
  inline Road() : Road(nullptr) {}
  ~Road() override;
  explicit PROTOBUF_CONSTEXPR Road(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Road(const Road& from);
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  inline Road& operator=(Road&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Road& default_instance() {
    return *internal_default_instance();
  }
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }
  inline void Swap(Road* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Road* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Road* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Road& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Road& from) {
    Road::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Road* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.Road";
  }
  protected:
  explicit Road(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepthFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // double depth = 2 [json_name = "depth"];
  void clear_depth();
  double depth() const;
  void set_depth(double value);
  private:
  double _internal_depth() const;
  void _internal_set_depth(double value);
  public:

  // int32 id = 1 [json_name = "id"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.Road)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double depth_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class RoadFlood final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.RoadFlood) */ {
 public:
  inline RoadFlood() : RoadFlood(nullptr) {}
  ~RoadFlood() override;
  explicit PROTOBUF_CONSTEXPR RoadFlood(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoadFlood(const RoadFlood& from);
  RoadFlood(RoadFlood&& from) noexcept
    : RoadFlood() {
    *this = ::std::move(from);
  }

  inline RoadFlood& operator=(const RoadFlood& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadFlood& operator=(RoadFlood&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadFlood& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadFlood* internal_default_instance() {
    return reinterpret_cast<const RoadFlood*>(
               &_RoadFlood_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoadFlood& a, RoadFlood& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadFlood* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadFlood* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadFlood* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadFlood>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoadFlood& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoadFlood& from) {
    RoadFlood::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadFlood* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.RoadFlood";
  }
  protected:
  explicit RoadFlood(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kDepthFieldNumber = 2,
  };
  // .city.geo.v2.LongLatPosition position = 1 [json_name = "position"];
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::city::geo::v2::LongLatPosition& position() const;
  PROTOBUF_NODISCARD ::city::geo::v2::LongLatPosition* release_position();
  ::city::geo::v2::LongLatPosition* mutable_position();
  void set_allocated_position(::city::geo::v2::LongLatPosition* position);
  private:
  const ::city::geo::v2::LongLatPosition& _internal_position() const;
  ::city::geo::v2::LongLatPosition* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::city::geo::v2::LongLatPosition* position);
  ::city::geo::v2::LongLatPosition* unsafe_arena_release_position();

  // double depth = 2 [json_name = "depth"];
  void clear_depth();
  double depth() const;
  void set_depth(double value);
  private:
  double _internal_depth() const;
  void _internal_set_depth(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.RoadFlood)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::city::geo::v2::LongLatPosition* position_;
    double depth_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class DetailedRoad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.DetailedRoad) */ {
 public:
  inline DetailedRoad() : DetailedRoad(nullptr) {}
  ~DetailedRoad() override;
  explicit PROTOBUF_CONSTEXPR DetailedRoad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailedRoad(const DetailedRoad& from);
  DetailedRoad(DetailedRoad&& from) noexcept
    : DetailedRoad() {
    *this = ::std::move(from);
  }

  inline DetailedRoad& operator=(const DetailedRoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailedRoad& operator=(DetailedRoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetailedRoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailedRoad* internal_default_instance() {
    return reinterpret_cast<const DetailedRoad*>(
               &_DetailedRoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DetailedRoad& a, DetailedRoad& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailedRoad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailedRoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetailedRoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetailedRoad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetailedRoad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetailedRoad& from) {
    DetailedRoad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailedRoad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.DetailedRoad";
  }
  protected:
  explicit DetailedRoad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepthsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .city.water.output.v1.RoadFlood depths = 2 [json_name = "depths"];
  int depths_size() const;
  private:
  int _internal_depths_size() const;
  public:
  void clear_depths();
  ::city::water::output::v1::RoadFlood* mutable_depths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::water::output::v1::RoadFlood >*
      mutable_depths();
  private:
  const ::city::water::output::v1::RoadFlood& _internal_depths(int index) const;
  ::city::water::output::v1::RoadFlood* _internal_add_depths();
  public:
  const ::city::water::output::v1::RoadFlood& depths(int index) const;
  ::city::water::output::v1::RoadFlood* add_depths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::water::output::v1::RoadFlood >&
      depths() const;

  // int32 id = 1 [json_name = "id"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.DetailedRoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::water::output::v1::RoadFlood > depths_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHeadFieldNumber = 2,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // double head = 2 [json_name = "head"];
  void clear_head();
  double head() const;
  void set_head(double value);
  private:
  double _internal_head() const;
  void _internal_set_head(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    double head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kFlowFieldNumber = 3,
    kTypeFieldNumber = 2,
    kOkFieldNumber = 4,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // double flow = 3 [json_name = "flow"];
  void clear_flow();
  double flow() const;
  void set_flow(double value);
  private:
  double _internal_flow() const;
  void _internal_set_flow(double value);
  public:

  // .city.water.output.v1.LinkType type = 2 [json_name = "type"];
  void clear_type();
  ::city::water::output::v1::LinkType type() const;
  void set_type(::city::water::output::v1::LinkType value);
  private:
  ::city::water::output::v1::LinkType _internal_type() const;
  void _internal_set_type(::city::water::output::v1::LinkType value);
  public:

  // bool ok = 4 [json_name = "ok"];
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    double flow_;
    int type_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class Aoi final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.Aoi) */ {
 public:
  inline Aoi() : Aoi(nullptr) {}
  ~Aoi() override;
  explicit PROTOBUF_CONSTEXPR Aoi(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aoi(const Aoi& from);
  Aoi(Aoi&& from) noexcept
    : Aoi() {
    *this = ::std::move(from);
  }

  inline Aoi& operator=(const Aoi& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aoi& operator=(Aoi&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aoi& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aoi* internal_default_instance() {
    return reinterpret_cast<const Aoi*>(
               &_Aoi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Aoi& a, Aoi& b) {
    a.Swap(&b);
  }
  inline void Swap(Aoi* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aoi* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aoi* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aoi>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aoi& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Aoi& from) {
    Aoi::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aoi* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.Aoi";
  }
  protected:
  explicit Aoi(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kUnsatisfiedNumFieldNumber = 2,
    kUnsatisfiedRatioFieldNumber = 3,
    kDemandFieldNumber = 4,
    kSupplyFieldNumber = 5,
  };
  // int32 id = 1 [json_name = "id"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 unsatisfied_num = 2 [json_name = "unsatisfiedNum"];
  void clear_unsatisfied_num();
  int32_t unsatisfied_num() const;
  void set_unsatisfied_num(int32_t value);
  private:
  int32_t _internal_unsatisfied_num() const;
  void _internal_set_unsatisfied_num(int32_t value);
  public:

  // double unsatisfied_ratio = 3 [json_name = "unsatisfiedRatio"];
  void clear_unsatisfied_ratio();
  double unsatisfied_ratio() const;
  void set_unsatisfied_ratio(double value);
  private:
  double _internal_unsatisfied_ratio() const;
  void _internal_set_unsatisfied_ratio(double value);
  public:

  // double demand = 4 [json_name = "demand"];
  void clear_demand();
  double demand() const;
  void set_demand(double value);
  private:
  double _internal_demand() const;
  void _internal_set_demand(double value);
  public:

  // double supply = 5 [json_name = "supply"];
  void clear_supply();
  double supply() const;
  void set_supply(double value);
  private:
  double _internal_supply() const;
  void _internal_set_supply(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.Aoi)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    int32_t unsatisfied_num_;
    double unsatisfied_ratio_;
    double demand_;
    double supply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class DrainageBasicInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.DrainageBasicInfo) */ {
 public:
  inline DrainageBasicInfo() : DrainageBasicInfo(nullptr) {}
  ~DrainageBasicInfo() override;
  explicit PROTOBUF_CONSTEXPR DrainageBasicInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrainageBasicInfo(const DrainageBasicInfo& from);
  DrainageBasicInfo(DrainageBasicInfo&& from) noexcept
    : DrainageBasicInfo() {
    *this = ::std::move(from);
  }

  inline DrainageBasicInfo& operator=(const DrainageBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrainageBasicInfo& operator=(DrainageBasicInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrainageBasicInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrainageBasicInfo* internal_default_instance() {
    return reinterpret_cast<const DrainageBasicInfo*>(
               &_DrainageBasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DrainageBasicInfo& a, DrainageBasicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DrainageBasicInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrainageBasicInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrainageBasicInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrainageBasicInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrainageBasicInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrainageBasicInfo& from) {
    DrainageBasicInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrainageBasicInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.DrainageBasicInfo";
  }
  protected:
  explicit DrainageBasicInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAveragePowerFieldNumber = 1,
    kUndrainedVolumeFieldNumber = 2,
    kDrainedVolumeFieldNumber = 3,
    kAverageFlowFieldNumber = 4,
    kFloodedVolumeFieldNumber = 5,
  };
  // double average_power = 1 [json_name = "averagePower"];
  void clear_average_power();
  double average_power() const;
  void set_average_power(double value);
  private:
  double _internal_average_power() const;
  void _internal_set_average_power(double value);
  public:

  // double undrained_volume = 2 [json_name = "undrainedVolume"];
  void clear_undrained_volume();
  double undrained_volume() const;
  void set_undrained_volume(double value);
  private:
  double _internal_undrained_volume() const;
  void _internal_set_undrained_volume(double value);
  public:

  // double drained_volume = 3 [json_name = "drainedVolume"];
  void clear_drained_volume();
  double drained_volume() const;
  void set_drained_volume(double value);
  private:
  double _internal_drained_volume() const;
  void _internal_set_drained_volume(double value);
  public:

  // double average_flow = 4 [json_name = "averageFlow"];
  void clear_average_flow();
  double average_flow() const;
  void set_average_flow(double value);
  private:
  double _internal_average_flow() const;
  void _internal_set_average_flow(double value);
  public:

  // double flooded_volume = 5 [json_name = "floodedVolume"];
  void clear_flooded_volume();
  double flooded_volume() const;
  void set_flooded_volume(double value);
  private:
  double _internal_flooded_volume() const;
  void _internal_set_flooded_volume(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.DrainageBasicInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double average_power_;
    double undrained_volume_;
    double drained_volume_;
    double average_flow_;
    double flooded_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class SupplyBasicInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.SupplyBasicInfo) */ {
 public:
  inline SupplyBasicInfo() : SupplyBasicInfo(nullptr) {}
  ~SupplyBasicInfo() override;
  explicit PROTOBUF_CONSTEXPR SupplyBasicInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupplyBasicInfo(const SupplyBasicInfo& from);
  SupplyBasicInfo(SupplyBasicInfo&& from) noexcept
    : SupplyBasicInfo() {
    *this = ::std::move(from);
  }

  inline SupplyBasicInfo& operator=(const SupplyBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyBasicInfo& operator=(SupplyBasicInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupplyBasicInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupplyBasicInfo* internal_default_instance() {
    return reinterpret_cast<const SupplyBasicInfo*>(
               &_SupplyBasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SupplyBasicInfo& a, SupplyBasicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyBasicInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyBasicInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupplyBasicInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupplyBasicInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SupplyBasicInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SupplyBasicInfo& from) {
    SupplyBasicInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyBasicInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.SupplyBasicInfo";
  }
  protected:
  explicit SupplyBasicInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAveragePowerFieldNumber = 1,
    kAverageFlowFieldNumber = 2,
  };
  // double average_power = 1 [json_name = "averagePower"];
  void clear_average_power();
  double average_power() const;
  void set_average_power(double value);
  private:
  double _internal_average_power() const;
  void _internal_set_average_power(double value);
  public:

  // double average_flow = 2 [json_name = "averageFlow"];
  void clear_average_flow();
  double average_flow() const;
  void set_average_flow(double value);
  private:
  double _internal_average_flow() const;
  void _internal_set_average_flow(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.SupplyBasicInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double average_power_;
    double average_flow_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class SupplyDemandStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.SupplyDemandStatistics) */ {
 public:
  inline SupplyDemandStatistics() : SupplyDemandStatistics(nullptr) {}
  ~SupplyDemandStatistics() override;
  explicit PROTOBUF_CONSTEXPR SupplyDemandStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupplyDemandStatistics(const SupplyDemandStatistics& from);
  SupplyDemandStatistics(SupplyDemandStatistics&& from) noexcept
    : SupplyDemandStatistics() {
    *this = ::std::move(from);
  }

  inline SupplyDemandStatistics& operator=(const SupplyDemandStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyDemandStatistics& operator=(SupplyDemandStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupplyDemandStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupplyDemandStatistics* internal_default_instance() {
    return reinterpret_cast<const SupplyDemandStatistics*>(
               &_SupplyDemandStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SupplyDemandStatistics& a, SupplyDemandStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyDemandStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyDemandStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupplyDemandStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupplyDemandStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SupplyDemandStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SupplyDemandStatistics& from) {
    SupplyDemandStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyDemandStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.SupplyDemandStatistics";
  }
  protected:
  explicit SupplyDemandStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonsDemandFieldNumber = 1,
    kUnsatisfiedPersonsRatioFieldNumber = 3,
    kUnsatisfiedPersonsFieldNumber = 2,
    kUnsatisfiedAoisFieldNumber = 5,
    kAoisDemandFieldNumber = 4,
    kUnsatisfiedAoisRatioFieldNumber = 6,
  };
  // double persons_demand = 1 [json_name = "personsDemand"];
  void clear_persons_demand();
  double persons_demand() const;
  void set_persons_demand(double value);
  private:
  double _internal_persons_demand() const;
  void _internal_set_persons_demand(double value);
  public:

  // double unsatisfied_persons_ratio = 3 [json_name = "unsatisfiedPersonsRatio"];
  void clear_unsatisfied_persons_ratio();
  double unsatisfied_persons_ratio() const;
  void set_unsatisfied_persons_ratio(double value);
  private:
  double _internal_unsatisfied_persons_ratio() const;
  void _internal_set_unsatisfied_persons_ratio(double value);
  public:

  // int32 unsatisfied_persons = 2 [json_name = "unsatisfiedPersons"];
  void clear_unsatisfied_persons();
  int32_t unsatisfied_persons() const;
  void set_unsatisfied_persons(int32_t value);
  private:
  int32_t _internal_unsatisfied_persons() const;
  void _internal_set_unsatisfied_persons(int32_t value);
  public:

  // int32 unsatisfied_aois = 5 [json_name = "unsatisfiedAois"];
  void clear_unsatisfied_aois();
  int32_t unsatisfied_aois() const;
  void set_unsatisfied_aois(int32_t value);
  private:
  int32_t _internal_unsatisfied_aois() const;
  void _internal_set_unsatisfied_aois(int32_t value);
  public:

  // double aois_demand = 4 [json_name = "aoisDemand"];
  void clear_aois_demand();
  double aois_demand() const;
  void set_aois_demand(double value);
  private:
  double _internal_aois_demand() const;
  void _internal_set_aois_demand(double value);
  public:

  // double unsatisfied_aois_ratio = 6 [json_name = "unsatisfiedAoisRatio"];
  void clear_unsatisfied_aois_ratio();
  double unsatisfied_aois_ratio() const;
  void set_unsatisfied_aois_ratio(double value);
  private:
  double _internal_unsatisfied_aois_ratio() const;
  void _internal_set_unsatisfied_aois_ratio(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.SupplyDemandStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double persons_demand_;
    double unsatisfied_persons_ratio_;
    int32_t unsatisfied_persons_;
    int32_t unsatisfied_aois_;
    double aois_demand_;
    double unsatisfied_aois_ratio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class FailureStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.FailureStatistics) */ {
 public:
  inline FailureStatistics() : FailureStatistics(nullptr) {}
  ~FailureStatistics() override;
  explicit PROTOBUF_CONSTEXPR FailureStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureStatistics(const FailureStatistics& from);
  FailureStatistics(FailureStatistics&& from) noexcept
    : FailureStatistics() {
    *this = ::std::move(from);
  }

  inline FailureStatistics& operator=(const FailureStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureStatistics& operator=(FailureStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureStatistics* internal_default_instance() {
    return reinterpret_cast<const FailureStatistics*>(
               &_FailureStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FailureStatistics& a, FailureStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailureStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FailureStatistics& from) {
    FailureStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailureStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.FailureStatistics";
  }
  protected:
  explicit FailureStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFailureNumFieldNumber = 1,
    kNormalNumFieldNumber = 2,
    kFailureRatioFieldNumber = 3,
  };
  // int32 failure_num = 1 [json_name = "failureNum"];
  void clear_failure_num();
  int32_t failure_num() const;
  void set_failure_num(int32_t value);
  private:
  int32_t _internal_failure_num() const;
  void _internal_set_failure_num(int32_t value);
  public:

  // int32 normal_num = 2 [json_name = "normalNum"];
  void clear_normal_num();
  int32_t normal_num() const;
  void set_normal_num(int32_t value);
  private:
  int32_t _internal_normal_num() const;
  void _internal_set_normal_num(int32_t value);
  public:

  // double failure_ratio = 3 [json_name = "failureRatio"];
  void clear_failure_ratio();
  double failure_ratio() const;
  void set_failure_ratio(double value);
  private:
  double _internal_failure_ratio() const;
  void _internal_set_failure_ratio(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.FailureStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t failure_num_;
    int32_t normal_num_;
    double failure_ratio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class DrainageMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.DrainageMetrics) */ {
 public:
  inline DrainageMetrics() : DrainageMetrics(nullptr) {}
  ~DrainageMetrics() override;
  explicit PROTOBUF_CONSTEXPR DrainageMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrainageMetrics(const DrainageMetrics& from);
  DrainageMetrics(DrainageMetrics&& from) noexcept
    : DrainageMetrics() {
    *this = ::std::move(from);
  }

  inline DrainageMetrics& operator=(const DrainageMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrainageMetrics& operator=(DrainageMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrainageMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrainageMetrics* internal_default_instance() {
    return reinterpret_cast<const DrainageMetrics*>(
               &_DrainageMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DrainageMetrics& a, DrainageMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(DrainageMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrainageMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrainageMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrainageMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrainageMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrainageMetrics& from) {
    DrainageMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrainageMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.DrainageMetrics";
  }
  protected:
  explicit DrainageMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrainageBasicInfoFieldNumber = 1,
    kFailureStatisticsFieldNumber = 3,
    kLoadRatioFieldNumber = 2,
  };
  // .city.water.output.v1.DrainageBasicInfo drainage_basic_info = 1 [json_name = "drainageBasicInfo"];
  bool has_drainage_basic_info() const;
  private:
  bool _internal_has_drainage_basic_info() const;
  public:
  void clear_drainage_basic_info();
  const ::city::water::output::v1::DrainageBasicInfo& drainage_basic_info() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::DrainageBasicInfo* release_drainage_basic_info();
  ::city::water::output::v1::DrainageBasicInfo* mutable_drainage_basic_info();
  void set_allocated_drainage_basic_info(::city::water::output::v1::DrainageBasicInfo* drainage_basic_info);
  private:
  const ::city::water::output::v1::DrainageBasicInfo& _internal_drainage_basic_info() const;
  ::city::water::output::v1::DrainageBasicInfo* _internal_mutable_drainage_basic_info();
  public:
  void unsafe_arena_set_allocated_drainage_basic_info(
      ::city::water::output::v1::DrainageBasicInfo* drainage_basic_info);
  ::city::water::output::v1::DrainageBasicInfo* unsafe_arena_release_drainage_basic_info();

  // .city.water.output.v1.FailureStatistics failure_statistics = 3 [json_name = "failureStatistics"];
  bool has_failure_statistics() const;
  private:
  bool _internal_has_failure_statistics() const;
  public:
  void clear_failure_statistics();
  const ::city::water::output::v1::FailureStatistics& failure_statistics() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::FailureStatistics* release_failure_statistics();
  ::city::water::output::v1::FailureStatistics* mutable_failure_statistics();
  void set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* failure_statistics);
  private:
  const ::city::water::output::v1::FailureStatistics& _internal_failure_statistics() const;
  ::city::water::output::v1::FailureStatistics* _internal_mutable_failure_statistics();
  public:
  void unsafe_arena_set_allocated_failure_statistics(
      ::city::water::output::v1::FailureStatistics* failure_statistics);
  ::city::water::output::v1::FailureStatistics* unsafe_arena_release_failure_statistics();

  // double load_ratio = 2 [json_name = "loadRatio"];
  void clear_load_ratio();
  double load_ratio() const;
  void set_load_ratio(double value);
  private:
  double _internal_load_ratio() const;
  void _internal_set_load_ratio(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.DrainageMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::city::water::output::v1::DrainageBasicInfo* drainage_basic_info_;
    ::city::water::output::v1::FailureStatistics* failure_statistics_;
    double load_ratio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// -------------------------------------------------------------------

class SupplyMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:city.water.output.v1.SupplyMetrics) */ {
 public:
  inline SupplyMetrics() : SupplyMetrics(nullptr) {}
  ~SupplyMetrics() override;
  explicit PROTOBUF_CONSTEXPR SupplyMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SupplyMetrics(const SupplyMetrics& from);
  SupplyMetrics(SupplyMetrics&& from) noexcept
    : SupplyMetrics() {
    *this = ::std::move(from);
  }

  inline SupplyMetrics& operator=(const SupplyMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SupplyMetrics& operator=(SupplyMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SupplyMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SupplyMetrics* internal_default_instance() {
    return reinterpret_cast<const SupplyMetrics*>(
               &_SupplyMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SupplyMetrics& a, SupplyMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(SupplyMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SupplyMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SupplyMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SupplyMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SupplyMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SupplyMetrics& from) {
    SupplyMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SupplyMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "city.water.output.v1.SupplyMetrics";
  }
  protected:
  explicit SupplyMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupplyBasicInfoFieldNumber = 1,
    kSupplyDemandStatisticsFieldNumber = 2,
    kFailureStatisticsFieldNumber = 4,
    kLoadRatioFieldNumber = 3,
  };
  // .city.water.output.v1.SupplyBasicInfo supply_basic_info = 1 [json_name = "supplyBasicInfo"];
  bool has_supply_basic_info() const;
  private:
  bool _internal_has_supply_basic_info() const;
  public:
  void clear_supply_basic_info();
  const ::city::water::output::v1::SupplyBasicInfo& supply_basic_info() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::SupplyBasicInfo* release_supply_basic_info();
  ::city::water::output::v1::SupplyBasicInfo* mutable_supply_basic_info();
  void set_allocated_supply_basic_info(::city::water::output::v1::SupplyBasicInfo* supply_basic_info);
  private:
  const ::city::water::output::v1::SupplyBasicInfo& _internal_supply_basic_info() const;
  ::city::water::output::v1::SupplyBasicInfo* _internal_mutable_supply_basic_info();
  public:
  void unsafe_arena_set_allocated_supply_basic_info(
      ::city::water::output::v1::SupplyBasicInfo* supply_basic_info);
  ::city::water::output::v1::SupplyBasicInfo* unsafe_arena_release_supply_basic_info();

  // .city.water.output.v1.SupplyDemandStatistics supply_demand_statistics = 2 [json_name = "supplyDemandStatistics"];
  bool has_supply_demand_statistics() const;
  private:
  bool _internal_has_supply_demand_statistics() const;
  public:
  void clear_supply_demand_statistics();
  const ::city::water::output::v1::SupplyDemandStatistics& supply_demand_statistics() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::SupplyDemandStatistics* release_supply_demand_statistics();
  ::city::water::output::v1::SupplyDemandStatistics* mutable_supply_demand_statistics();
  void set_allocated_supply_demand_statistics(::city::water::output::v1::SupplyDemandStatistics* supply_demand_statistics);
  private:
  const ::city::water::output::v1::SupplyDemandStatistics& _internal_supply_demand_statistics() const;
  ::city::water::output::v1::SupplyDemandStatistics* _internal_mutable_supply_demand_statistics();
  public:
  void unsafe_arena_set_allocated_supply_demand_statistics(
      ::city::water::output::v1::SupplyDemandStatistics* supply_demand_statistics);
  ::city::water::output::v1::SupplyDemandStatistics* unsafe_arena_release_supply_demand_statistics();

  // .city.water.output.v1.FailureStatistics failure_statistics = 4 [json_name = "failureStatistics"];
  bool has_failure_statistics() const;
  private:
  bool _internal_has_failure_statistics() const;
  public:
  void clear_failure_statistics();
  const ::city::water::output::v1::FailureStatistics& failure_statistics() const;
  PROTOBUF_NODISCARD ::city::water::output::v1::FailureStatistics* release_failure_statistics();
  ::city::water::output::v1::FailureStatistics* mutable_failure_statistics();
  void set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* failure_statistics);
  private:
  const ::city::water::output::v1::FailureStatistics& _internal_failure_statistics() const;
  ::city::water::output::v1::FailureStatistics* _internal_mutable_failure_statistics();
  public:
  void unsafe_arena_set_allocated_failure_statistics(
      ::city::water::output::v1::FailureStatistics* failure_statistics);
  ::city::water::output::v1::FailureStatistics* unsafe_arena_release_failure_statistics();

  // double load_ratio = 3 [json_name = "loadRatio"];
  void clear_load_ratio();
  double load_ratio() const;
  void set_load_ratio(double value);
  private:
  double _internal_load_ratio() const;
  void _internal_set_load_ratio(double value);
  public:

  // @@protoc_insertion_point(class_scope:city.water.output.v1.SupplyMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::city::water::output::v1::SupplyBasicInfo* supply_basic_info_;
    ::city::water::output::v1::SupplyDemandStatistics* supply_demand_statistics_;
    ::city::water::output::v1::FailureStatistics* failure_statistics_;
    double load_ratio_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_city_2fwater_2foutput_2fv1_2foutput_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Road

// int32 id = 1 [json_name = "id"];
inline void Road::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Road::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Road::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Road.id)
  return _internal_id();
}
inline void Road::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Road::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Road.id)
}

// double depth = 2 [json_name = "depth"];
inline void Road::clear_depth() {
  _impl_.depth_ = 0;
}
inline double Road::_internal_depth() const {
  return _impl_.depth_;
}
inline double Road::depth() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Road.depth)
  return _internal_depth();
}
inline void Road::_internal_set_depth(double value) {
  
  _impl_.depth_ = value;
}
inline void Road::set_depth(double value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Road.depth)
}

// -------------------------------------------------------------------

// RoadFlood

// .city.geo.v2.LongLatPosition position = 1 [json_name = "position"];
inline bool RoadFlood::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool RoadFlood::has_position() const {
  return _internal_has_position();
}
inline const ::city::geo::v2::LongLatPosition& RoadFlood::_internal_position() const {
  const ::city::geo::v2::LongLatPosition* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::geo::v2::LongLatPosition&>(
      ::city::geo::v2::_LongLatPosition_default_instance_);
}
inline const ::city::geo::v2::LongLatPosition& RoadFlood::position() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.RoadFlood.position)
  return _internal_position();
}
inline void RoadFlood::unsafe_arena_set_allocated_position(
    ::city::geo::v2::LongLatPosition* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.RoadFlood.position)
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::release_position() {
  
  ::city::geo::v2::LongLatPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.RoadFlood.position)
  
  ::city::geo::v2::LongLatPosition* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::geo::v2::LongLatPosition>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::city::geo::v2::LongLatPosition* RoadFlood::mutable_position() {
  ::city::geo::v2::LongLatPosition* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.RoadFlood.position)
  return _msg;
}
inline void RoadFlood::set_allocated_position(::city::geo::v2::LongLatPosition* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.RoadFlood.position)
}

// double depth = 2 [json_name = "depth"];
inline void RoadFlood::clear_depth() {
  _impl_.depth_ = 0;
}
inline double RoadFlood::_internal_depth() const {
  return _impl_.depth_;
}
inline double RoadFlood::depth() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.RoadFlood.depth)
  return _internal_depth();
}
inline void RoadFlood::_internal_set_depth(double value) {
  
  _impl_.depth_ = value;
}
inline void RoadFlood::set_depth(double value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.RoadFlood.depth)
}

// -------------------------------------------------------------------

// DetailedRoad

// int32 id = 1 [json_name = "id"];
inline void DetailedRoad::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t DetailedRoad::_internal_id() const {
  return _impl_.id_;
}
inline int32_t DetailedRoad::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DetailedRoad.id)
  return _internal_id();
}
inline void DetailedRoad::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void DetailedRoad::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DetailedRoad.id)
}

// repeated .city.water.output.v1.RoadFlood depths = 2 [json_name = "depths"];
inline int DetailedRoad::_internal_depths_size() const {
  return _impl_.depths_.size();
}
inline int DetailedRoad::depths_size() const {
  return _internal_depths_size();
}
inline void DetailedRoad::clear_depths() {
  _impl_.depths_.Clear();
}
inline ::city::water::output::v1::RoadFlood* DetailedRoad::mutable_depths(int index) {
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.DetailedRoad.depths)
  return _impl_.depths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::water::output::v1::RoadFlood >*
DetailedRoad::mutable_depths() {
  // @@protoc_insertion_point(field_mutable_list:city.water.output.v1.DetailedRoad.depths)
  return &_impl_.depths_;
}
inline const ::city::water::output::v1::RoadFlood& DetailedRoad::_internal_depths(int index) const {
  return _impl_.depths_.Get(index);
}
inline const ::city::water::output::v1::RoadFlood& DetailedRoad::depths(int index) const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DetailedRoad.depths)
  return _internal_depths(index);
}
inline ::city::water::output::v1::RoadFlood* DetailedRoad::_internal_add_depths() {
  return _impl_.depths_.Add();
}
inline ::city::water::output::v1::RoadFlood* DetailedRoad::add_depths() {
  ::city::water::output::v1::RoadFlood* _add = _internal_add_depths();
  // @@protoc_insertion_point(field_add:city.water.output.v1.DetailedRoad.depths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::city::water::output::v1::RoadFlood >&
DetailedRoad::depths() const {
  // @@protoc_insertion_point(field_list:city.water.output.v1.DetailedRoad.depths)
  return _impl_.depths_;
}

// -------------------------------------------------------------------

// Node

// string id = 1 [json_name = "id"];
inline void Node::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Node::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Node.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:city.water.output.v1.Node.id)
}
inline std::string* Node::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.Node.id)
  return _s;
}
inline const std::string& Node::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Node::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_id() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.Node.id)
  return _impl_.id_.Release();
}
inline void Node::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.Node.id)
}

// double head = 2 [json_name = "head"];
inline void Node::clear_head() {
  _impl_.head_ = 0;
}
inline double Node::_internal_head() const {
  return _impl_.head_;
}
inline double Node::head() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Node.head)
  return _internal_head();
}
inline void Node::_internal_set_head(double value) {
  
  _impl_.head_ = value;
}
inline void Node::set_head(double value) {
  _internal_set_head(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Node.head)
}

// -------------------------------------------------------------------

// Link

// string id = 1 [json_name = "id"];
inline void Link::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Link::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.id)
}
inline std::string* Link::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.Link.id)
  return _s;
}
inline const std::string& Link::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Link::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_id() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.Link.id)
  return _impl_.id_.Release();
}
inline void Link::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.Link.id)
}

// .city.water.output.v1.LinkType type = 2 [json_name = "type"];
inline void Link::clear_type() {
  _impl_.type_ = 0;
}
inline ::city::water::output::v1::LinkType Link::_internal_type() const {
  return static_cast< ::city::water::output::v1::LinkType >(_impl_.type_);
}
inline ::city::water::output::v1::LinkType Link::type() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.type)
  return _internal_type();
}
inline void Link::_internal_set_type(::city::water::output::v1::LinkType value) {
  
  _impl_.type_ = value;
}
inline void Link::set_type(::city::water::output::v1::LinkType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.type)
}

// double flow = 3 [json_name = "flow"];
inline void Link::clear_flow() {
  _impl_.flow_ = 0;
}
inline double Link::_internal_flow() const {
  return _impl_.flow_;
}
inline double Link::flow() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.flow)
  return _internal_flow();
}
inline void Link::_internal_set_flow(double value) {
  
  _impl_.flow_ = value;
}
inline void Link::set_flow(double value) {
  _internal_set_flow(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.flow)
}

// bool ok = 4 [json_name = "ok"];
inline void Link::clear_ok() {
  _impl_.ok_ = false;
}
inline bool Link::_internal_ok() const {
  return _impl_.ok_;
}
inline bool Link::ok() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Link.ok)
  return _internal_ok();
}
inline void Link::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void Link::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Link.ok)
}

// -------------------------------------------------------------------

// Aoi

// int32 id = 1 [json_name = "id"];
inline void Aoi::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Aoi::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Aoi::id() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.id)
  return _internal_id();
}
inline void Aoi::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Aoi::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.id)
}

// int32 unsatisfied_num = 2 [json_name = "unsatisfiedNum"];
inline void Aoi::clear_unsatisfied_num() {
  _impl_.unsatisfied_num_ = 0;
}
inline int32_t Aoi::_internal_unsatisfied_num() const {
  return _impl_.unsatisfied_num_;
}
inline int32_t Aoi::unsatisfied_num() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.unsatisfied_num)
  return _internal_unsatisfied_num();
}
inline void Aoi::_internal_set_unsatisfied_num(int32_t value) {
  
  _impl_.unsatisfied_num_ = value;
}
inline void Aoi::set_unsatisfied_num(int32_t value) {
  _internal_set_unsatisfied_num(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.unsatisfied_num)
}

// double unsatisfied_ratio = 3 [json_name = "unsatisfiedRatio"];
inline void Aoi::clear_unsatisfied_ratio() {
  _impl_.unsatisfied_ratio_ = 0;
}
inline double Aoi::_internal_unsatisfied_ratio() const {
  return _impl_.unsatisfied_ratio_;
}
inline double Aoi::unsatisfied_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.unsatisfied_ratio)
  return _internal_unsatisfied_ratio();
}
inline void Aoi::_internal_set_unsatisfied_ratio(double value) {
  
  _impl_.unsatisfied_ratio_ = value;
}
inline void Aoi::set_unsatisfied_ratio(double value) {
  _internal_set_unsatisfied_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.unsatisfied_ratio)
}

// double demand = 4 [json_name = "demand"];
inline void Aoi::clear_demand() {
  _impl_.demand_ = 0;
}
inline double Aoi::_internal_demand() const {
  return _impl_.demand_;
}
inline double Aoi::demand() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.demand)
  return _internal_demand();
}
inline void Aoi::_internal_set_demand(double value) {
  
  _impl_.demand_ = value;
}
inline void Aoi::set_demand(double value) {
  _internal_set_demand(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.demand)
}

// double supply = 5 [json_name = "supply"];
inline void Aoi::clear_supply() {
  _impl_.supply_ = 0;
}
inline double Aoi::_internal_supply() const {
  return _impl_.supply_;
}
inline double Aoi::supply() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.Aoi.supply)
  return _internal_supply();
}
inline void Aoi::_internal_set_supply(double value) {
  
  _impl_.supply_ = value;
}
inline void Aoi::set_supply(double value) {
  _internal_set_supply(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.Aoi.supply)
}

// -------------------------------------------------------------------

// DrainageBasicInfo

// double average_power = 1 [json_name = "averagePower"];
inline void DrainageBasicInfo::clear_average_power() {
  _impl_.average_power_ = 0;
}
inline double DrainageBasicInfo::_internal_average_power() const {
  return _impl_.average_power_;
}
inline double DrainageBasicInfo::average_power() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.average_power)
  return _internal_average_power();
}
inline void DrainageBasicInfo::_internal_set_average_power(double value) {
  
  _impl_.average_power_ = value;
}
inline void DrainageBasicInfo::set_average_power(double value) {
  _internal_set_average_power(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.average_power)
}

// double undrained_volume = 2 [json_name = "undrainedVolume"];
inline void DrainageBasicInfo::clear_undrained_volume() {
  _impl_.undrained_volume_ = 0;
}
inline double DrainageBasicInfo::_internal_undrained_volume() const {
  return _impl_.undrained_volume_;
}
inline double DrainageBasicInfo::undrained_volume() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.undrained_volume)
  return _internal_undrained_volume();
}
inline void DrainageBasicInfo::_internal_set_undrained_volume(double value) {
  
  _impl_.undrained_volume_ = value;
}
inline void DrainageBasicInfo::set_undrained_volume(double value) {
  _internal_set_undrained_volume(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.undrained_volume)
}

// double drained_volume = 3 [json_name = "drainedVolume"];
inline void DrainageBasicInfo::clear_drained_volume() {
  _impl_.drained_volume_ = 0;
}
inline double DrainageBasicInfo::_internal_drained_volume() const {
  return _impl_.drained_volume_;
}
inline double DrainageBasicInfo::drained_volume() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.drained_volume)
  return _internal_drained_volume();
}
inline void DrainageBasicInfo::_internal_set_drained_volume(double value) {
  
  _impl_.drained_volume_ = value;
}
inline void DrainageBasicInfo::set_drained_volume(double value) {
  _internal_set_drained_volume(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.drained_volume)
}

// double average_flow = 4 [json_name = "averageFlow"];
inline void DrainageBasicInfo::clear_average_flow() {
  _impl_.average_flow_ = 0;
}
inline double DrainageBasicInfo::_internal_average_flow() const {
  return _impl_.average_flow_;
}
inline double DrainageBasicInfo::average_flow() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.average_flow)
  return _internal_average_flow();
}
inline void DrainageBasicInfo::_internal_set_average_flow(double value) {
  
  _impl_.average_flow_ = value;
}
inline void DrainageBasicInfo::set_average_flow(double value) {
  _internal_set_average_flow(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.average_flow)
}

// double flooded_volume = 5 [json_name = "floodedVolume"];
inline void DrainageBasicInfo::clear_flooded_volume() {
  _impl_.flooded_volume_ = 0;
}
inline double DrainageBasicInfo::_internal_flooded_volume() const {
  return _impl_.flooded_volume_;
}
inline double DrainageBasicInfo::flooded_volume() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageBasicInfo.flooded_volume)
  return _internal_flooded_volume();
}
inline void DrainageBasicInfo::_internal_set_flooded_volume(double value) {
  
  _impl_.flooded_volume_ = value;
}
inline void DrainageBasicInfo::set_flooded_volume(double value) {
  _internal_set_flooded_volume(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageBasicInfo.flooded_volume)
}

// -------------------------------------------------------------------

// SupplyBasicInfo

// double average_power = 1 [json_name = "averagePower"];
inline void SupplyBasicInfo::clear_average_power() {
  _impl_.average_power_ = 0;
}
inline double SupplyBasicInfo::_internal_average_power() const {
  return _impl_.average_power_;
}
inline double SupplyBasicInfo::average_power() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyBasicInfo.average_power)
  return _internal_average_power();
}
inline void SupplyBasicInfo::_internal_set_average_power(double value) {
  
  _impl_.average_power_ = value;
}
inline void SupplyBasicInfo::set_average_power(double value) {
  _internal_set_average_power(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyBasicInfo.average_power)
}

// double average_flow = 2 [json_name = "averageFlow"];
inline void SupplyBasicInfo::clear_average_flow() {
  _impl_.average_flow_ = 0;
}
inline double SupplyBasicInfo::_internal_average_flow() const {
  return _impl_.average_flow_;
}
inline double SupplyBasicInfo::average_flow() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyBasicInfo.average_flow)
  return _internal_average_flow();
}
inline void SupplyBasicInfo::_internal_set_average_flow(double value) {
  
  _impl_.average_flow_ = value;
}
inline void SupplyBasicInfo::set_average_flow(double value) {
  _internal_set_average_flow(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyBasicInfo.average_flow)
}

// -------------------------------------------------------------------

// SupplyDemandStatistics

// double persons_demand = 1 [json_name = "personsDemand"];
inline void SupplyDemandStatistics::clear_persons_demand() {
  _impl_.persons_demand_ = 0;
}
inline double SupplyDemandStatistics::_internal_persons_demand() const {
  return _impl_.persons_demand_;
}
inline double SupplyDemandStatistics::persons_demand() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.persons_demand)
  return _internal_persons_demand();
}
inline void SupplyDemandStatistics::_internal_set_persons_demand(double value) {
  
  _impl_.persons_demand_ = value;
}
inline void SupplyDemandStatistics::set_persons_demand(double value) {
  _internal_set_persons_demand(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.persons_demand)
}

// int32 unsatisfied_persons = 2 [json_name = "unsatisfiedPersons"];
inline void SupplyDemandStatistics::clear_unsatisfied_persons() {
  _impl_.unsatisfied_persons_ = 0;
}
inline int32_t SupplyDemandStatistics::_internal_unsatisfied_persons() const {
  return _impl_.unsatisfied_persons_;
}
inline int32_t SupplyDemandStatistics::unsatisfied_persons() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons)
  return _internal_unsatisfied_persons();
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_persons(int32_t value) {
  
  _impl_.unsatisfied_persons_ = value;
}
inline void SupplyDemandStatistics::set_unsatisfied_persons(int32_t value) {
  _internal_set_unsatisfied_persons(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons)
}

// double unsatisfied_persons_ratio = 3 [json_name = "unsatisfiedPersonsRatio"];
inline void SupplyDemandStatistics::clear_unsatisfied_persons_ratio() {
  _impl_.unsatisfied_persons_ratio_ = 0;
}
inline double SupplyDemandStatistics::_internal_unsatisfied_persons_ratio() const {
  return _impl_.unsatisfied_persons_ratio_;
}
inline double SupplyDemandStatistics::unsatisfied_persons_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons_ratio)
  return _internal_unsatisfied_persons_ratio();
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_persons_ratio(double value) {
  
  _impl_.unsatisfied_persons_ratio_ = value;
}
inline void SupplyDemandStatistics::set_unsatisfied_persons_ratio(double value) {
  _internal_set_unsatisfied_persons_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_persons_ratio)
}

// double aois_demand = 4 [json_name = "aoisDemand"];
inline void SupplyDemandStatistics::clear_aois_demand() {
  _impl_.aois_demand_ = 0;
}
inline double SupplyDemandStatistics::_internal_aois_demand() const {
  return _impl_.aois_demand_;
}
inline double SupplyDemandStatistics::aois_demand() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.aois_demand)
  return _internal_aois_demand();
}
inline void SupplyDemandStatistics::_internal_set_aois_demand(double value) {
  
  _impl_.aois_demand_ = value;
}
inline void SupplyDemandStatistics::set_aois_demand(double value) {
  _internal_set_aois_demand(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.aois_demand)
}

// int32 unsatisfied_aois = 5 [json_name = "unsatisfiedAois"];
inline void SupplyDemandStatistics::clear_unsatisfied_aois() {
  _impl_.unsatisfied_aois_ = 0;
}
inline int32_t SupplyDemandStatistics::_internal_unsatisfied_aois() const {
  return _impl_.unsatisfied_aois_;
}
inline int32_t SupplyDemandStatistics::unsatisfied_aois() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois)
  return _internal_unsatisfied_aois();
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_aois(int32_t value) {
  
  _impl_.unsatisfied_aois_ = value;
}
inline void SupplyDemandStatistics::set_unsatisfied_aois(int32_t value) {
  _internal_set_unsatisfied_aois(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois)
}

// double unsatisfied_aois_ratio = 6 [json_name = "unsatisfiedAoisRatio"];
inline void SupplyDemandStatistics::clear_unsatisfied_aois_ratio() {
  _impl_.unsatisfied_aois_ratio_ = 0;
}
inline double SupplyDemandStatistics::_internal_unsatisfied_aois_ratio() const {
  return _impl_.unsatisfied_aois_ratio_;
}
inline double SupplyDemandStatistics::unsatisfied_aois_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois_ratio)
  return _internal_unsatisfied_aois_ratio();
}
inline void SupplyDemandStatistics::_internal_set_unsatisfied_aois_ratio(double value) {
  
  _impl_.unsatisfied_aois_ratio_ = value;
}
inline void SupplyDemandStatistics::set_unsatisfied_aois_ratio(double value) {
  _internal_set_unsatisfied_aois_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyDemandStatistics.unsatisfied_aois_ratio)
}

// -------------------------------------------------------------------

// FailureStatistics

// int32 failure_num = 1 [json_name = "failureNum"];
inline void FailureStatistics::clear_failure_num() {
  _impl_.failure_num_ = 0;
}
inline int32_t FailureStatistics::_internal_failure_num() const {
  return _impl_.failure_num_;
}
inline int32_t FailureStatistics::failure_num() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.FailureStatistics.failure_num)
  return _internal_failure_num();
}
inline void FailureStatistics::_internal_set_failure_num(int32_t value) {
  
  _impl_.failure_num_ = value;
}
inline void FailureStatistics::set_failure_num(int32_t value) {
  _internal_set_failure_num(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.FailureStatistics.failure_num)
}

// int32 normal_num = 2 [json_name = "normalNum"];
inline void FailureStatistics::clear_normal_num() {
  _impl_.normal_num_ = 0;
}
inline int32_t FailureStatistics::_internal_normal_num() const {
  return _impl_.normal_num_;
}
inline int32_t FailureStatistics::normal_num() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.FailureStatistics.normal_num)
  return _internal_normal_num();
}
inline void FailureStatistics::_internal_set_normal_num(int32_t value) {
  
  _impl_.normal_num_ = value;
}
inline void FailureStatistics::set_normal_num(int32_t value) {
  _internal_set_normal_num(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.FailureStatistics.normal_num)
}

// double failure_ratio = 3 [json_name = "failureRatio"];
inline void FailureStatistics::clear_failure_ratio() {
  _impl_.failure_ratio_ = 0;
}
inline double FailureStatistics::_internal_failure_ratio() const {
  return _impl_.failure_ratio_;
}
inline double FailureStatistics::failure_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.FailureStatistics.failure_ratio)
  return _internal_failure_ratio();
}
inline void FailureStatistics::_internal_set_failure_ratio(double value) {
  
  _impl_.failure_ratio_ = value;
}
inline void FailureStatistics::set_failure_ratio(double value) {
  _internal_set_failure_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.FailureStatistics.failure_ratio)
}

// -------------------------------------------------------------------

// DrainageMetrics

// .city.water.output.v1.DrainageBasicInfo drainage_basic_info = 1 [json_name = "drainageBasicInfo"];
inline bool DrainageMetrics::_internal_has_drainage_basic_info() const {
  return this != internal_default_instance() && _impl_.drainage_basic_info_ != nullptr;
}
inline bool DrainageMetrics::has_drainage_basic_info() const {
  return _internal_has_drainage_basic_info();
}
inline void DrainageMetrics::clear_drainage_basic_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.drainage_basic_info_ != nullptr) {
    delete _impl_.drainage_basic_info_;
  }
  _impl_.drainage_basic_info_ = nullptr;
}
inline const ::city::water::output::v1::DrainageBasicInfo& DrainageMetrics::_internal_drainage_basic_info() const {
  const ::city::water::output::v1::DrainageBasicInfo* p = _impl_.drainage_basic_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::DrainageBasicInfo&>(
      ::city::water::output::v1::_DrainageBasicInfo_default_instance_);
}
inline const ::city::water::output::v1::DrainageBasicInfo& DrainageMetrics::drainage_basic_info() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageMetrics.drainage_basic_info)
  return _internal_drainage_basic_info();
}
inline void DrainageMetrics::unsafe_arena_set_allocated_drainage_basic_info(
    ::city::water::output::v1::DrainageBasicInfo* drainage_basic_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drainage_basic_info_);
  }
  _impl_.drainage_basic_info_ = drainage_basic_info;
  if (drainage_basic_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.DrainageMetrics.drainage_basic_info)
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::release_drainage_basic_info() {
  
  ::city::water::output::v1::DrainageBasicInfo* temp = _impl_.drainage_basic_info_;
  _impl_.drainage_basic_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::unsafe_arena_release_drainage_basic_info() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.DrainageMetrics.drainage_basic_info)
  
  ::city::water::output::v1::DrainageBasicInfo* temp = _impl_.drainage_basic_info_;
  _impl_.drainage_basic_info_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::_internal_mutable_drainage_basic_info() {
  
  if (_impl_.drainage_basic_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::DrainageBasicInfo>(GetArenaForAllocation());
    _impl_.drainage_basic_info_ = p;
  }
  return _impl_.drainage_basic_info_;
}
inline ::city::water::output::v1::DrainageBasicInfo* DrainageMetrics::mutable_drainage_basic_info() {
  ::city::water::output::v1::DrainageBasicInfo* _msg = _internal_mutable_drainage_basic_info();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.DrainageMetrics.drainage_basic_info)
  return _msg;
}
inline void DrainageMetrics::set_allocated_drainage_basic_info(::city::water::output::v1::DrainageBasicInfo* drainage_basic_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.drainage_basic_info_;
  }
  if (drainage_basic_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(drainage_basic_info);
    if (message_arena != submessage_arena) {
      drainage_basic_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drainage_basic_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.drainage_basic_info_ = drainage_basic_info;
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.DrainageMetrics.drainage_basic_info)
}

// double load_ratio = 2 [json_name = "loadRatio"];
inline void DrainageMetrics::clear_load_ratio() {
  _impl_.load_ratio_ = 0;
}
inline double DrainageMetrics::_internal_load_ratio() const {
  return _impl_.load_ratio_;
}
inline double DrainageMetrics::load_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageMetrics.load_ratio)
  return _internal_load_ratio();
}
inline void DrainageMetrics::_internal_set_load_ratio(double value) {
  
  _impl_.load_ratio_ = value;
}
inline void DrainageMetrics::set_load_ratio(double value) {
  _internal_set_load_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.DrainageMetrics.load_ratio)
}

// .city.water.output.v1.FailureStatistics failure_statistics = 3 [json_name = "failureStatistics"];
inline bool DrainageMetrics::_internal_has_failure_statistics() const {
  return this != internal_default_instance() && _impl_.failure_statistics_ != nullptr;
}
inline bool DrainageMetrics::has_failure_statistics() const {
  return _internal_has_failure_statistics();
}
inline void DrainageMetrics::clear_failure_statistics() {
  if (GetArenaForAllocation() == nullptr && _impl_.failure_statistics_ != nullptr) {
    delete _impl_.failure_statistics_;
  }
  _impl_.failure_statistics_ = nullptr;
}
inline const ::city::water::output::v1::FailureStatistics& DrainageMetrics::_internal_failure_statistics() const {
  const ::city::water::output::v1::FailureStatistics* p = _impl_.failure_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::FailureStatistics&>(
      ::city::water::output::v1::_FailureStatistics_default_instance_);
}
inline const ::city::water::output::v1::FailureStatistics& DrainageMetrics::failure_statistics() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.DrainageMetrics.failure_statistics)
  return _internal_failure_statistics();
}
inline void DrainageMetrics::unsafe_arena_set_allocated_failure_statistics(
    ::city::water::output::v1::FailureStatistics* failure_statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.failure_statistics_);
  }
  _impl_.failure_statistics_ = failure_statistics;
  if (failure_statistics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.DrainageMetrics.failure_statistics)
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::release_failure_statistics() {
  
  ::city::water::output::v1::FailureStatistics* temp = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::unsafe_arena_release_failure_statistics() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.DrainageMetrics.failure_statistics)
  
  ::city::water::output::v1::FailureStatistics* temp = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::_internal_mutable_failure_statistics() {
  
  if (_impl_.failure_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::FailureStatistics>(GetArenaForAllocation());
    _impl_.failure_statistics_ = p;
  }
  return _impl_.failure_statistics_;
}
inline ::city::water::output::v1::FailureStatistics* DrainageMetrics::mutable_failure_statistics() {
  ::city::water::output::v1::FailureStatistics* _msg = _internal_mutable_failure_statistics();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.DrainageMetrics.failure_statistics)
  return _msg;
}
inline void DrainageMetrics::set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* failure_statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.failure_statistics_;
  }
  if (failure_statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(failure_statistics);
    if (message_arena != submessage_arena) {
      failure_statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure_statistics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.failure_statistics_ = failure_statistics;
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.DrainageMetrics.failure_statistics)
}

// -------------------------------------------------------------------

// SupplyMetrics

// .city.water.output.v1.SupplyBasicInfo supply_basic_info = 1 [json_name = "supplyBasicInfo"];
inline bool SupplyMetrics::_internal_has_supply_basic_info() const {
  return this != internal_default_instance() && _impl_.supply_basic_info_ != nullptr;
}
inline bool SupplyMetrics::has_supply_basic_info() const {
  return _internal_has_supply_basic_info();
}
inline void SupplyMetrics::clear_supply_basic_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.supply_basic_info_ != nullptr) {
    delete _impl_.supply_basic_info_;
  }
  _impl_.supply_basic_info_ = nullptr;
}
inline const ::city::water::output::v1::SupplyBasicInfo& SupplyMetrics::_internal_supply_basic_info() const {
  const ::city::water::output::v1::SupplyBasicInfo* p = _impl_.supply_basic_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::SupplyBasicInfo&>(
      ::city::water::output::v1::_SupplyBasicInfo_default_instance_);
}
inline const ::city::water::output::v1::SupplyBasicInfo& SupplyMetrics::supply_basic_info() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.supply_basic_info)
  return _internal_supply_basic_info();
}
inline void SupplyMetrics::unsafe_arena_set_allocated_supply_basic_info(
    ::city::water::output::v1::SupplyBasicInfo* supply_basic_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supply_basic_info_);
  }
  _impl_.supply_basic_info_ = supply_basic_info;
  if (supply_basic_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.SupplyMetrics.supply_basic_info)
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::release_supply_basic_info() {
  
  ::city::water::output::v1::SupplyBasicInfo* temp = _impl_.supply_basic_info_;
  _impl_.supply_basic_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::unsafe_arena_release_supply_basic_info() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.SupplyMetrics.supply_basic_info)
  
  ::city::water::output::v1::SupplyBasicInfo* temp = _impl_.supply_basic_info_;
  _impl_.supply_basic_info_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::_internal_mutable_supply_basic_info() {
  
  if (_impl_.supply_basic_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::SupplyBasicInfo>(GetArenaForAllocation());
    _impl_.supply_basic_info_ = p;
  }
  return _impl_.supply_basic_info_;
}
inline ::city::water::output::v1::SupplyBasicInfo* SupplyMetrics::mutable_supply_basic_info() {
  ::city::water::output::v1::SupplyBasicInfo* _msg = _internal_mutable_supply_basic_info();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.SupplyMetrics.supply_basic_info)
  return _msg;
}
inline void SupplyMetrics::set_allocated_supply_basic_info(::city::water::output::v1::SupplyBasicInfo* supply_basic_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supply_basic_info_;
  }
  if (supply_basic_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supply_basic_info);
    if (message_arena != submessage_arena) {
      supply_basic_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supply_basic_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.supply_basic_info_ = supply_basic_info;
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.SupplyMetrics.supply_basic_info)
}

// .city.water.output.v1.SupplyDemandStatistics supply_demand_statistics = 2 [json_name = "supplyDemandStatistics"];
inline bool SupplyMetrics::_internal_has_supply_demand_statistics() const {
  return this != internal_default_instance() && _impl_.supply_demand_statistics_ != nullptr;
}
inline bool SupplyMetrics::has_supply_demand_statistics() const {
  return _internal_has_supply_demand_statistics();
}
inline void SupplyMetrics::clear_supply_demand_statistics() {
  if (GetArenaForAllocation() == nullptr && _impl_.supply_demand_statistics_ != nullptr) {
    delete _impl_.supply_demand_statistics_;
  }
  _impl_.supply_demand_statistics_ = nullptr;
}
inline const ::city::water::output::v1::SupplyDemandStatistics& SupplyMetrics::_internal_supply_demand_statistics() const {
  const ::city::water::output::v1::SupplyDemandStatistics* p = _impl_.supply_demand_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::SupplyDemandStatistics&>(
      ::city::water::output::v1::_SupplyDemandStatistics_default_instance_);
}
inline const ::city::water::output::v1::SupplyDemandStatistics& SupplyMetrics::supply_demand_statistics() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
  return _internal_supply_demand_statistics();
}
inline void SupplyMetrics::unsafe_arena_set_allocated_supply_demand_statistics(
    ::city::water::output::v1::SupplyDemandStatistics* supply_demand_statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.supply_demand_statistics_);
  }
  _impl_.supply_demand_statistics_ = supply_demand_statistics;
  if (supply_demand_statistics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::release_supply_demand_statistics() {
  
  ::city::water::output::v1::SupplyDemandStatistics* temp = _impl_.supply_demand_statistics_;
  _impl_.supply_demand_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::unsafe_arena_release_supply_demand_statistics() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
  
  ::city::water::output::v1::SupplyDemandStatistics* temp = _impl_.supply_demand_statistics_;
  _impl_.supply_demand_statistics_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::_internal_mutable_supply_demand_statistics() {
  
  if (_impl_.supply_demand_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::SupplyDemandStatistics>(GetArenaForAllocation());
    _impl_.supply_demand_statistics_ = p;
  }
  return _impl_.supply_demand_statistics_;
}
inline ::city::water::output::v1::SupplyDemandStatistics* SupplyMetrics::mutable_supply_demand_statistics() {
  ::city::water::output::v1::SupplyDemandStatistics* _msg = _internal_mutable_supply_demand_statistics();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
  return _msg;
}
inline void SupplyMetrics::set_allocated_supply_demand_statistics(::city::water::output::v1::SupplyDemandStatistics* supply_demand_statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.supply_demand_statistics_;
  }
  if (supply_demand_statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(supply_demand_statistics);
    if (message_arena != submessage_arena) {
      supply_demand_statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, supply_demand_statistics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.supply_demand_statistics_ = supply_demand_statistics;
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.SupplyMetrics.supply_demand_statistics)
}

// double load_ratio = 3 [json_name = "loadRatio"];
inline void SupplyMetrics::clear_load_ratio() {
  _impl_.load_ratio_ = 0;
}
inline double SupplyMetrics::_internal_load_ratio() const {
  return _impl_.load_ratio_;
}
inline double SupplyMetrics::load_ratio() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.load_ratio)
  return _internal_load_ratio();
}
inline void SupplyMetrics::_internal_set_load_ratio(double value) {
  
  _impl_.load_ratio_ = value;
}
inline void SupplyMetrics::set_load_ratio(double value) {
  _internal_set_load_ratio(value);
  // @@protoc_insertion_point(field_set:city.water.output.v1.SupplyMetrics.load_ratio)
}

// .city.water.output.v1.FailureStatistics failure_statistics = 4 [json_name = "failureStatistics"];
inline bool SupplyMetrics::_internal_has_failure_statistics() const {
  return this != internal_default_instance() && _impl_.failure_statistics_ != nullptr;
}
inline bool SupplyMetrics::has_failure_statistics() const {
  return _internal_has_failure_statistics();
}
inline void SupplyMetrics::clear_failure_statistics() {
  if (GetArenaForAllocation() == nullptr && _impl_.failure_statistics_ != nullptr) {
    delete _impl_.failure_statistics_;
  }
  _impl_.failure_statistics_ = nullptr;
}
inline const ::city::water::output::v1::FailureStatistics& SupplyMetrics::_internal_failure_statistics() const {
  const ::city::water::output::v1::FailureStatistics* p = _impl_.failure_statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::city::water::output::v1::FailureStatistics&>(
      ::city::water::output::v1::_FailureStatistics_default_instance_);
}
inline const ::city::water::output::v1::FailureStatistics& SupplyMetrics::failure_statistics() const {
  // @@protoc_insertion_point(field_get:city.water.output.v1.SupplyMetrics.failure_statistics)
  return _internal_failure_statistics();
}
inline void SupplyMetrics::unsafe_arena_set_allocated_failure_statistics(
    ::city::water::output::v1::FailureStatistics* failure_statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.failure_statistics_);
  }
  _impl_.failure_statistics_ = failure_statistics;
  if (failure_statistics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:city.water.output.v1.SupplyMetrics.failure_statistics)
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::release_failure_statistics() {
  
  ::city::water::output::v1::FailureStatistics* temp = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::unsafe_arena_release_failure_statistics() {
  // @@protoc_insertion_point(field_release:city.water.output.v1.SupplyMetrics.failure_statistics)
  
  ::city::water::output::v1::FailureStatistics* temp = _impl_.failure_statistics_;
  _impl_.failure_statistics_ = nullptr;
  return temp;
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::_internal_mutable_failure_statistics() {
  
  if (_impl_.failure_statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::city::water::output::v1::FailureStatistics>(GetArenaForAllocation());
    _impl_.failure_statistics_ = p;
  }
  return _impl_.failure_statistics_;
}
inline ::city::water::output::v1::FailureStatistics* SupplyMetrics::mutable_failure_statistics() {
  ::city::water::output::v1::FailureStatistics* _msg = _internal_mutable_failure_statistics();
  // @@protoc_insertion_point(field_mutable:city.water.output.v1.SupplyMetrics.failure_statistics)
  return _msg;
}
inline void SupplyMetrics::set_allocated_failure_statistics(::city::water::output::v1::FailureStatistics* failure_statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.failure_statistics_;
  }
  if (failure_statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(failure_statistics);
    if (message_arena != submessage_arena) {
      failure_statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure_statistics, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.failure_statistics_ = failure_statistics;
  // @@protoc_insertion_point(field_set_allocated:city.water.output.v1.SupplyMetrics.failure_statistics)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace output
}  // namespace water
}  // namespace city

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::city::water::output::v1::LinkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::city::water::output::v1::LinkType>() {
  return ::city::water::output::v1::LinkType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_city_2fwater_2foutput_2fv1_2foutput_2eproto

syntax = "proto3";

package simulet.proto.route.v1;

option go_package = "proto/routev1";

import "simulet/geo/v1/geo.proto";

enum RouteType {
  ROUTE_TYPE_UNKNOWN = 0;
  ROUTE_TYPE_DRIVING = 1;
  ROUTE_TYPE_WALKING = 2;
  ROUTE_TYPE_BY_BUS = 3;
}

enum TripType {
  TRIP_TYPE_UNKNOWN = 0;
  TRIP_TYPE_DRIVING = 1;
  TRIP_TYPE_WALKING = 2;
  TRIP_TYPE_BY_BUS = 3;
  TRIP_TYPE_BY_TAXI = 4;
}

// describe how the vehicle goes into the next lane from the current lane
enum NextLaneType {
  NEXT_LANE_TYPE_UNKNOWN = 0;
  // the next lane is the successor of the current lane
  NEXT_LANE_TYPE_FORWARD = 1;
  // the next lane is the left neighbor of the current lane
  NEXT_LANE_TYPE_LEFT = 2;
  // the next lane is the right neighbor of the current lane
  NEXT_LANE_TYPE_RIGHT = 3;
  // the current lane is the last one, no next lane
  NEXT_LANE_TYPE_LAST = 4;
}

message RouteSegment {
  uint32 lane_id = 1;
  NextLaneType next_lane_type = 2;
}

// lanes sequence
// hint: the agent should pass the end of one lane in lanes
// (except the last lane or the lane whose next lane is its neighbor)
message DrivingTripBody {
  repeated RouteSegment route = 1;
}

message WalkingTripBody {
  simulet.proto.geo.v1.NavigateRoute route = 1;
}

message BusTripBody {
  // TODO(zhangjun): not implemented
}

message TaxiTripBody {
  // TODO(zhangjun): not implemented
}

// one part of route, which contains only ONE mode of travel
message Trip {
  TripType type = 1;
  oneof trip_body {
    DrivingTripBody driving = 2;
    WalkingTripBody walking = 3;
    BusTripBody by_bus = 4;
    TaxiTripBody by_taxi = 5;
  }
}
